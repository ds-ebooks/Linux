{"./":{"url":"./","title":"简介","keywords":"","body":"简介 Linux入门知识，参考https://billie66.github.io/TLCL/book/ 写的总结。 Copyright © 2018 S all right reserved，powered by Gitbook该文件修订时间： 2018-09-21 15:57:30 "},"post/01-learn-shell.html":{"url":"post/01-learn-shell.html","title":"学习Shell","summary":"学习一下shell入门知识","keywords":"","body":"一、什么是 shell “bash” 是 “Bourne Again SHell” 的首字母缩写， 所指的是这样一个事实，bash 是最初 Unix 上由 Steve Bourne 写成 shell 程序 sh 的增强版。能够访问Shell的终端仿真器称为“terminal”。 如果终端提示符的最后一个字符是“#”, 而不是“$”, 那么这个终端会话就有超级用户权限。 这意味着，我们或者是以 root 用户的身份登录，或者是我们选择的终端仿真器提供超级用户（管理员）权限。 许多 Linux 发行版默认保存最后输入的500个命令。 按下下箭头按键，先前输入的命令就消失了。鼠标中键拷贝高亮的文本到光标所在的位置。 简单命令 date;cal;df;free;exit alien@localhost:~$ date 2018年 09月 16日 星期日 10:29:55 CST alien@localhost:~$ cal 九月 2018 日 一 二 三 四 五 六 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 alien@localhost:~$ df 文件系统 1K-块 已用 可用 已用% 挂载点 udev 1947612 0 1947612 0% /dev tmpfs 394980 6452 388528 2% /run /dev/sda10 25357412 7711332 16334952 33% / tmpfs 1974892 68392 1906500 4% /dev/shm tmpfs 5120 4 5116 1% /run/lock tmpfs 1974892 0 1974892 0% /sys/fs/cgroup tmpfs 394980 84 394896 1% /run/user/1000 /dev/sda6 133953532 88401188 45552344 66% /media/alien/File Sharing alien@localhost:~$ free total used free shared buff/cache available Mem: 3949784 1415584 983500 271940 1550700 1975800 Swap: 4102140 0 4102140 alien@localhost:~$ exit 查看磁盘剩余空间的数量，输入 df. 显示空闲内存的数量，输入命令 free. 幕后控制台 即使终端仿真器没有运行，在后台仍然有几个终端会话运行着。它们叫做虚拟终端 或者是虚拟控制台。在大多数 Linux 发行版中，这些终端会话都可以通过按下 Ctrl-Alt-F1 到 Ctrl-Alt-F6 访问。当一个会话被访问的时候， 它会显示登录提示框，我们需要输入用户名和密码。要从一个虚拟控制台转换到另一个， 按下 Alt 和 F1-F6(中的一个)。返回图形桌面，按下 Alt-F7。 二、文件系统中的跳转 pwd - Print name of current working directory cd - Change directory ls - List directory contents 当我们首次登录系统（或者启动终端仿真器会话）后，当前工作目录是我们的家目录。 每个用户都有他自己的家目录，当用户以普通用户的身份操控系统时，家目录是唯一 允许用户写入文件的地方。 绝对路径 绝对路径开始于根目录，紧跟着目录树的一个个分支，一直到达所期望的目录或文件。 alien@localhost:~$ cd /usr/bin alien@localhost:/usr/bin$ pwd /usr/bin 相对路径 相对路径开始于工作目录，， 我们在文件系统树中用一对特殊符号来表示相对位置。 这对特殊符号是 “.” (点) 和 “..” (点点)。符号 “.” 指的是工作目录，”..” 指的是工作目录的父目录。在几乎所有的情况下，你可以省略”./”。它是隐含的。 快捷键 运行结果 cd 更改工作目录到你的家目录。 cd - 更改工作目录到先前的工作目录。 cd ~user_name 更改工作目录到用户家目录。例如, cd ~bob 会更改工作目录到用户“bob”的家目录。 ls -a 命令可以列出以 “.” 字符开头的隐藏文件，一些应用程序会把它们的配置文件以隐藏文件的形式放在你的家目录下面，文件名和命令名是大小写敏感的。 三、探究操作系统 ls – List directory contents file – Determine file type less – View file contents ls ls 可以列出多个目录： alien@localhost:~$ ls ~ /usr /home/alien: app examples.desktop sys 公共的 视频 文档 音乐 Calibre 书库 PycharmProjects VirtualBox VMs 模板 图片 下载 桌面 /usr: bin games include lib lib64 local locale sbin share src ls常用命令选项： 选项 长选项 描述 -a --all 列出所有文件，甚至包括文件名以圆点开头的默认会被隐藏的隐藏文件。 -d --directory 通常，如果指定了目录名，ls 命令会列出这个目录中的内容，而不是目录本身。 把这个选项与 -l 选项结合使用，可以看到所指定目录的详细信息，而不是目录中的内容。 -F --classify 这个选项会在每个所列出的名字后面加上一个指示符。例如，如果名字是 目录名，则会加上一个'/'字符。 -h --human-readable 当以长格式列出时，以人们可读的格式，自适应使用K，M等单位，而不是以字节数来显示文件的大小。 -l 以长格式显示结果。 -r --reverse 以相反的顺序来显示结果。通常，ls 命令的输出结果按照字母升序排列。 -S 命令输出结果按照文件大小来排序。 -t 按照修改时间来排序。 加上长选项 “–reverse”，则结果会以相反的顺序输出： $ ls -lt --reverse 长格式输出 alien@localhost:~$ ls -l 总用量 64 drwxrwxr-x 3 alien alien 4096 9月 15 21:19 app drwxrwxr-x 10 alien alien 4096 4月 12 17:25 Calibre 书库 -rw-r--r-- 1 alien alien 8980 11月 29 2017 examples.desktop drwxrwxr-x 3 alien alien 4096 9月 15 15:30 PycharmProjects drwxrwxr-x 2 alien alien 4096 9月 16 20:23 sys drwxrwxr-x 2 alien alien 4096 9月 16 20:49 VirtualBox VMs drwxr-xr-x 2 alien alien 4096 11月 30 2017 公共的 drwxr-xr-x 2 alien alien 4096 11月 30 2017 模板 drwxr-xr-x 2 alien alien 4096 11月 30 2017 视频 drwxr-xr-x 2 alien alien 4096 9月 15 22:52 图片 drwxr-xr-x 2 alien alien 4096 11月 30 2017 文档 drwxr-xr-x 2 alien alien 4096 12月 8 2017 下载 drwxr-xr-x 3 alien alien 4096 11月 30 2017 音乐 drwxr-xr-x 5 alien alien 4096 9月 17 08:10 桌面 字段 含义 -rw-r--r-- 对于文件的访问权限。第一个字符指明文件类型。在不同类型之间， 开头的“－”说明是一个普通文件，“d”表明是一个目录。其后三个字符是文件所有者的 访问权限，再其后的三个字符是文件所属组中成员的访问权限，最后三个字符是其他所 有人的访问权限。也就是一共十个字符。 1 文件的硬链接数目。 alien 文件所有者的用户名。 alien 文件所属用户组的名字。 8980 以字节数表示的文件大小。 11月 29 2017 上次修改文件的时间和日期。 examples.desktop 文件名。 确定文件类型 file filename Linux 中，有个普遍的观念就是“一切皆文件”。 用 less 浏览文件内容 许多包含系统设置的文件（叫做配置文件），是以文本格式存储的，实际程序（叫做脚本）也是以这种格式存储的。 # less 程序允许你前后滚动文件 less filename # 按下“q”键， 退出 less 程序 less参数： 命令 行为 Page UP or b 向上翻滚一页 Page Down or space 向下翻滚一页 UP Arrow 向上翻滚一行 Down Arrow 向下翻滚一行 G 移动到最后一行 1G or g 移动到开头一行 /charaters 向前查找指定的字符串 n 向前查找下一个出现的字符串，这个字符串是之前所指定查找的 h 显示帮助屏幕 q 退出 less 程序 less is more(色即是空) less 属于”页面调度器”类程序，这些程序允许以逐页方式轻松浏览长文本文档。 more 程序只能向前翻页，而 less 程序允许前后翻页，此外还有很多其它的特性。 Linux 系统中的目录 目录 评论 / 根目录，万物起源。 /bin 包含系统启动和运行所必须的二进制程序。 /boot 包含 Linux 内核、初始 RAM 磁盘映像（用于启动时所需的驱动）和 启动加载程序。有趣的文件：/boot/grub/grub.conf or menu.lst， 被用来配置启动加载程序。/boot/vmlinuz，Linux 内核。 /dev 这是一个包含设备结点的特殊目录。“一切都是文件”，也适用于设备。 在这个目录里，内核维护着所有设备的列表。 /etc 这个目录包含所有系统层面的配置文件。它也包含一系列的 shell 脚本， 在系统启动时，这些脚本会开启每个系统服务。这个目录中的任何文件应该是可读的文本文件。有趣的文件：虽然/etc 目录中的任何文件都有趣，但这里只列出了一些我一直喜欢的文件：/etc/crontab， 定义自动运行的任务。/etc/fstab，包含存储设备的列表，以及与他们相关的挂载点。/etc/passwd，包含用户帐号列表。 /home 在通常的配置环境下，系统会在/home 下，给每个用户分配一个目录。普通用户只能 在自己的目录下写文件。这个限制保护系统免受错误的用户活动破坏。 /lib 包含核心系统程序所使用的共享库文件。这些文件与 Windows 中的动态链接库相似。 /lost+found 每个使用 Linux 文件系统的格式化分区或设备，例如 ext3文件系统， 都会有这个目录。当部分恢复一个损坏的文件系统时，会用到这个目录。这个目录应该是空的，除非文件系统 真正的损坏了。 /media 在现在的 Linux 系统中，/media 目录会包含可移动介质的挂载点， 例如 USB 驱动器，CD-ROMs 等等。这些介质连接到计算机之后，会自动地挂载到这个目录结点下。 /mnt 在早些的 Linux 系统中，/mnt 目录包含可移动介质的挂载点。 /opt 这个/opt 目录被用来安装“可选的”软件。这个主要用来存储可能 安装在系统中的商业软件产品。 /proc 这个/proc 目录很特殊。从存储在硬盘上的文件的意义上说，它不是真正的文件系统。 相反，它是一个由 Linux 内核维护的虚拟文件系统。它所包含的文件是内核的窥视孔。这些文件是可读的， 它们会告诉你内核是怎样监管计算机的。 /root root 帐户的家目录。 /sbin 这个目录包含“系统”二进制文件。它们是完成重大系统任务的程序，通常为超级用户保留。 /tmp 这个/tmp 目录，是用来存储由各种程序创建的临时文件的地方。一些配置导致系统每次 重新启动时，都会清空这个目录。 /usr 在 Linux 系统中，/usr 目录可能是最大的一个。它包含普通用户所需要的所有程序和文件。 /usr/bin /usr/bin 目录包含系统安装的可执行程序。通常，这个目录会包含许多程序。 /usr/lib 包含由/usr/bin 目录中的程序所用的共享库。 /usr/local 这个/usr/local 目录，是非系统发行版自带程序的安装目录。 通常，由源码编译的程序会安装在/usr/local/bin 目录下。新安装的 Linux 系统中会存在这个目录， 并且在管理员安装程序之前，这个目录是空的。 /usr/sbin 包含许多系统管理程序。 /usr/share /usr/share 目录包含许多由/usr/bin 目录中的程序使用的共享数据。 其中包括像默认的配置文件、图标、桌面背景、音频文件等等。 /usr/share/doc 大多数安装在系统中的软件包会包含一些文档。在/usr/share/doc 目录下， 我们可以找到按照软件包分类的文档。 /var 除了/tmp 和/home 目录之外，相对来说，目前我们看到的目录是静态的，这是说， 它们的内容不会改变。/var 目录存放的是动态文件。各种数据库，假脱机文件， 用户邮件等等，都位于在这里。 /var/log 这个/var/log 目录包含日志文件、各种系统活动的记录。这些文件非常重要，并且 应该时时监测它们。其中最重要的一个文件是/var/log/messages。注意，为了系统安全，在一些系统中， 你必须是超级用户才能查看这些日志文件。 符号链接（软链接）----与Windows一样 lrwxrwxrwx 1 root root 11 2007-08-11 07:34 libc.so.6 -> libc-2.6.so “l”是符号链接（也称为软链接或者 symlink ），一个文件被多个文件名所指向，即多个拥有不同文件名的软链接指向同一个文件。上面libc.so.6是libc-2.6.so的软链接。 硬链接 一个硬链接不能关联它所在文件系统之外的文件。这是说一个链接不能关联 与链接本身不在同一个磁盘分区上的文件。 一个硬链接不能关联一个目录。 改变硬链接或原文件内容，与之相应的所有硬链接和源文件都会改变. 硬链接和软链接只是另一种形式上的快捷方式，只是硬链接像真正的文本而已。 四、操作文件和目录 cp — 复制文件和目录 mv — 移动/重命名文件和目录 mkdir — 创建目录 rm — 删除文件和目录 ln — 创建硬链接和符号链接 命令行程序，功能强大灵活，对于 复杂的文件操作任务，使用命令行程序比较容易完成。 通配符 通配符 意义 * 匹配任意多个字符（包括零个或一个） ? 匹配任意一个字符（不包括零个） [characters] 匹配任意一个属于字符集中的字符 [!characters] 匹配任意一个不是字符集中的字符 [[:class:]] 匹配任意一个属于指定字符类中的字符 普遍使用的字符类： 字符类 意义 [:alnum:] 匹配任意一个字母或数字 [:alpha:] 匹配任意一个字母 [:digit:] 匹配任意一个数字 [:lower:] 匹配任意一个小写字母 [:upper:] 匹配任意一个大写字母 通配符范例： 模式 匹配对象 * 所有文件 g* 文件名以“g”开头的文件 b*.txt 以\"b\"开头，中间有零个或任意多个字符，并以\".txt\"结尾的文件 Data??? 以“Data”开头，其后紧接着3个字符的文件 [abc]* 文件名以\"a\",\"b\",或\"c\"开头的文件 BACKUP.[0-9][0-9][0-9] 以\"BACKUP.\"开头，并紧接着3个数字的文件 [[:upper:]]* 以大写字母开头的文件 [![:digit:]]* 不以数字开头的文件 *[[:lower:]123] 文件名以小写字母结尾，或以 “1”，“2”，或 “3” 结尾的文件 避免使用[A-Z]或 [a-z]，用字符类来代替它们。 mkdir - 创建目录 在描述一个命令时（如上所示），当有三个圆点跟在一个命令的参数后面， 这意味着那个参数可以重复，就像这样：mkdir directory...---->mkdir dir1 dir2 dir3 cp - 复制文件和目录 cp item... directory 复制多个项目（文件或目录）到一个目录下。 选项 意义 -a, --archive 复制文件和目录，以及它们的属性，包括所有权和权限。 通常，复本具有用户所操作文件的默认属性。 -i, --interactive 在重写已存在文件之前，提示用户确认。如果这个选项不指定， cp 命令会默认重写文件。 -r, --recursive 递归地复制目录及目录中的内容。当复制目录时， 需要这个选项（或者-a 选项）。 -u, --update 当把文件从一个目录复制到另一个目录时，仅复制 目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在的文件。 -v, --verbose 显示翔实的命令操作信息 示例： 命令 运行结果 cp file1 file2 复制文件 file1 内容到文件 file2。如果 file2 已经存在， file2 的内容会被 file1 的内容重写。如果 file2 不存在，则会创建 file2。 cp -i file1 file2 这条命令和上面的命令一样，除了如果文件 file2 存在的话，在文件 file2 被重写之前， 会提示用户确认信息。 cp file1 file2 dir1 复制文件 file1 和文件 file2 到目录 dir1。目录 dir1 必须存在。 cp dir1/* dir2 使用一个通配符，在目录 dir1 中的所有文件都被复制到目录 dir2 中。 dir2 必须已经存在。 cp -r dir1 dir2 复制目录 dir1 中的内容到目录 dir2。如果目录 dir2 不存在， 创建目录 dir2，操作完成后，目录 dir2 中的内容和 dir1 中的一样。 如果目录 dir2 存在，则目录 dir1 (和目录中的内容)将会被复制到 dir2 中。 mv - 移动和重命名文件 与cp基本一样. mv item... directory 选项 意义 -i --interactive 在重写一个已经存在的文件之前，提示用户确认信息。 如果不指定这个选项，mv 命令会默认重写文件内容。 -u --update 当把文件从一个目录移动另一个目录时，只是移动不存在的文件， 或者文件内容新于目标目录相对应文件的内容。 -v --verbose 当操作 mv 命令时，显示翔实的操作信息。 示例： 命令 运行情况 mv file1 file2 移动 file1 到 file2。如果 file2 存在，它的内容会被 file1 的内容重写。 如果 file2 不存在，则创建 file2。 这两种情况下，file1 都不再存在。 mv -i file1 file2 除了如果 file2 存在的话，在 file2 被重写之前，用户会得到 提示信息外，这个和上面的选项一样。 mv file1 file2 dir1 移动 file1 和 file2 到目录 dir1 中。dir1 必须已经存在。 mv dir1 dir2 如果目录 dir2 不存在，创建目录 dir2，并且移动目录 dir1 的内容到 目录 dir2 中，同时删除目录 dir1。如果目录 dir2 存在，移动目录 dir1（及它的内容）到目录 dir2。 rm - 删除文件和目录 rm item... 选项 意义 -i, --interactive 在删除已存在的文件前，提示用户确认信息。 如果不指定这个选项，rm 会默默地删除文件 -r, --recursive 递归地删除文件，这意味着，如果要删除一个目录，而此目录 又包含子目录，那么子目录也会被删除。要删除一个目录，必须指定这个选项。 -f, --force 忽视不存在的文件，不显示提示信息。这选项覆盖了“--interactive”选项。 -v, --verbose 在执行 rm 命令时，显示翔实的操作信息。 示例： 命令 运行结果 rm file1 默默地删除文件 rm -i file1 除了在删除文件之前，提示用户确认信息之外，和上面的命令作用一样。 rm -r file1 dir1 删除文件 file1, 目录 dir1，及 dir1 中的内容。 rm -rf file1 dir1 同上，除了如果文件 file1，或目录 dir1 不存在的话，rm 仍会继续执行。 一般我们可以先用ls测试一下要删除的文件，再进行删除操作，防止误删。 ln — 创建链接 ln 命令既可创建硬链接，也可以创建符号链接（软链接）。 # 创建硬链接 ln file link # 创建符号链接，”item” 可以是一个文件或是一个目录 ln -s item link 五、使用命令 type – 说明怎样解释一个命令名 which – 显示会执行哪个可执行程序 man – 显示命令手册页 apropos – 显示一系列适合的命令 info – 显示命令 info whatis – 显示一个命令的简洁描述 alias – 创建命令别名 命令：可执行程序、内建于 shell 自身的命令、 shell 函数、命令别名 识别命令 type － 显示命令的类型：eg. type command，也就是上面四种命令之一。 which － 显示一个可执行程序的位置：eg. which ls . 这个命令只对可执行程序有效，不包括内建命令和命令别名，eg. which cp就不得不到回应。 使用命令文档 help － 得到 shell 内建命令的帮助文档 alien@localhost:~$ help cd cd: cd [-L|[-P [-e]] [-@]] [dir] Change the shell working directory. ... 命令文档表示法：出现在命令语法说明中的方括号，表示可选的项目。一个竖杠字符表示互斥选项。在上面 cd 命令的例子中：cd 命令可能有一个“-L”选项或者“-P”选项，进一步，可能有参数“dir”。 --help - 显示用法信息，显示命令所支持的语法和选项说明 alien@localhost:~$ mkdir --help 用法：mkdir [选项]... 目录... Create the DIRECTORY(ies), if they do not already exist. man － 显示程序手册页：eg. man ls 手册布局： 章节 内容 1 用户命令 2 程序接口内核系统调用 3 C 库函数程序接口 4 特殊文件，比如说设备结点和驱动程序 5 文件格式 6 游戏娱乐，如屏幕保护程序 7 其他方面 8 系统管理员命令 有时候，我们需要查看参考手册的特定章节，从而找到我们需要的信息：man section search_term，例如： alien@localhost:~$ man 5 passwd apropos － 搜索参考手册 alien@localhost:~$ apropos floppy fdformat (8) - low-level format a floppy disk mbadblocks (1) - tests a floppy disk, and marks the bad blocks in the FAT mformat (1) - add an MSDOS filesystem to a low-level formatted flopp... mxtar (1) - Wrapper for using GNU tar directly from a floppy disk 第一个字段是手册页的名字，第二个字段展示章节，man 命令加上”-k”选项， 和 apropos 完成一样的功能。 whatis － 显示非常简洁的命令说明 alien@localhost:~$ whatis ls ls (1) - list directory contents info － 显示程序 Info 条目 info 程序读取 info 文件，info 文件是树型结构，分化为各个结点，每一个包含一个题目。 info 文件包含超级链接，它可以让你从一个结点跳到另一个结点。一个超级链接可通过 它开头的星号来辨别出来，把光标放在它上面并按下 enter 键，就可以激活它。 info命令： 命令 行为 ? 显示命令帮助 PgUp or Backspace 显示上一页 PgDn or Space 显示下一页 n 下一个 - 显示下一个结点 p 上一个 - 显示上一个结点 u Up - 显示当前所显示结点的父结点，通常是个菜单 Enter 激活光标位置下的超级链接 q 退出 gzip 软件包包括一个特殊的 less 版本，叫做 zless，zless 可以显示由 gzip 压缩的文本文件的内容。 用别名（alias）创建你自己的命令 tips:把多个命令放在同一行上，命令之间 用”;”分开。command1; command2; command3... alien@localhost:~$ type foo bash: type: foo: 未找到 alien@localhost:~$ cd /usr; ls; cd - bin games include lib lib64 local locale sbin share src /home/alien 创建命令别名foo： alien@localhost:~$ alias foo='cd /usr; ls; cd -' alien@localhost:~$ alias name='string' alien@localhost:~$ foo bin games include lib lib64 local locale sbin share src /home/alien alien@localhost:~$ type foo foo 是 `cd /usr; ls; cd -' 的别名 删除别名： alien@localhost:~$ unalias foo alien@localhost:~$ type foo bash: type: foo: 未找到 在命令行中定义别名有点儿小问题。当你的 shell 会话结束时，它们会消失，后面会介绍怎样把自己的别名添加到文件中去，每次我们登录系统，这些文件会建立系统环境。 六、重定向 “>” “ I/O 重定向。”I/O”代表输入/输出， 通过这个工具，你可以重定向命令的输入输出，命令的输入来自文件，而输出也存到文件。 也可以把多个命令连接起来组成一个强大的命令管道。 cat － 连接文件 sort － 排序文本行 uniq － 报道或省略重复行 grep － 打印匹配行 wc － 打印文件中换行符，字，和字节个数 head － 输出文件第一部分 tail - 输出文件最后一部分 tee - 从标准输入读取数据，并同时写到标准输出和文件 # 这样会重写 ls-output.txt 文件 alien@localhost:~$ ls -l /usr/bin > ls-output.txt alien@localhost:~$ ls app ls-output.txt VirtualBox VMs 视频 下载 Calibre 书库 PycharmProjects 公共的 图片 音乐 examples.desktop sys 模板 文档 桌面 alien@localhost:~$ cat ls-output.txt 总用量 126424 -rwxr-xr-x 1 root root 51920 3月 3 2017 [ lrwxrwxrwx 1 root root 8 11月 24 2017 2to3 -> 2to3-2.7 ... 注意：ls 程序不把它的错误信息输送到标准输出。 tips：> ls-output.txt清空文件内容 使用”>>“重定向符，把重定向结果追加到文件内容后面：ls -l /usr/bin >> ls-output.txt 重定向标准输出和错误到同一个文件 一个程序可以在几个编号的文件流中的任一个上产生输出。这些文件流的前 三个称作标准输入、输出和错误，shell 内部分别将其称为文件描述符0、1和2。 alien@localhost:~$ ls -l /bin/usr > ls-output.txt 2>&1 alien@localhost:~$ ls -l /usr/bin >> ls-output.txt 2>&1 alien@localhost:~$ cat ls-output.txt ls: 无法访问'/bin/usr': 没有那个文件或目录 总用量 126424 -rwxr-xr-x 1 root root 51920 3月 3 2017 [ 标准错误的重定向必须总是出现在标准输出重定向之后，而且必须是上面这种格式 现在的bash版本提供了一种新方法&>：ls -l /bin/usr &> ls-output.txt 处理不需要的输出 隐瞒命令错误信息，我们这样做： alien@localhost:~$ ls -l /bin/usr 2> /dev/null alien@localhost:~$ 其中/dev/null的特殊文件， 是系统设备，叫做位存储桶，它可以接受输入，并且对输入不做任何处理。 标准输入重定向 cat 命令读取一个或多个文件，然后复制它们到标准输出。 tips: 创建一个叫做”lazy_dog.txt” 的文件： alien@localhost:~$ cat > lazy_dog.txt The quick brown fox jumped over the lazy dog. alien@localhost:~$ cat lazy_dog.txt The quick brown fox jumped over the lazy dog. # Ctrl+d退出 重定向标准输入：把标准输入源从键盘改到文件 lazy_dog.tx。 alien@localhost:~$ cat 管道线| command1 | command2一个命令的标准输出可以通过管道送至另一个命令的标准输入：$ ls -l /usr/bin | less 过滤器: 把几个命令放在一起组成一个管道线，以这种方式使用的命令被称为过滤器。 alien@localhost:~$ ls /bin /usr/bin | sort | less 我们指定了两个目录（/bin 和/usr/bin），ls 命令的输出结果由有序列表组成， 各自针对一个目录。通过在管道线中包含 sort，我们改变输出数据，从而产生一个 有序列表。 uniq - 忽略重复行 uniq 从标准输入或单个文件名参数接受数据有序列表默认情况下，从数据列表中删除任何重复行。 ls /bin /usr/bin | sort | uniq | less 如果想看到重复的数据列表，加上”-d”选项，就像这样：ls /bin /usr/bin | sort | uniq -d | less wc--grep--head--tail--tee wc － 打印行数、字数(单词数)和字节数，-l选项限制命令输出只能 报道行数。 alien@localhost:~$ wc ls-output.txt 3617 34113 232078 ls-output.txt alien@localhost:~$ ls /bin /usr/bin | sort | uniq | wc -l 1957 grep － 打印匹配行 grep pattern [file...]，当 grep 遇到一个文件中的匹配”模式”，它会打印出包含这个类型的行，这里再次强调了正则表达式的重要性。 # 找到文件名中包含单词”zip”的所有文 alien@localhost:~$ ls /bin /usr/bin | sort | uniq | grep zip bunzip2 bzip2 ... grep中的”-i”使得 grep 在执行搜索时忽略大小写（通常，搜索是大小写 敏感的），”-v”选项会告诉 grep 只打印不匹配的行。 head / tail － 打印文件开头部分/结尾部分 head 命令打印文件的前十行，而 tail 命令打印文件的后十行。默认情况下，两个命令 都打印十行文本，但是可以通过”-n”选项来调整命令打印的行数。 alien@localhost:~$ head -n 3 ls-output.txt ls: 无法访问'/bin/usr': 没有那个文件或目录 总用量 126424 -rwxr-xr-x 1 root root 51920 3月 3 2017 [ alien@localhost:~$ tail -n 3 ls-output.txt -rwxr-xr-x 1 root root 81840 8月 17 2015 zipsplit -rwxr-xr-x 1 root root 27064 4月 7 2016 zjsdecode -rwxr-xr-x 1 root root 10336 5月 2 21:42 zlib-flate alien@localhost:~$ ls /usr/bin | tail -n 3 zipsplit zjsdecode zlib-flate alien@localhost:~$ tee － 从 Stdin 读取数据，并同时输出到 Stdout 和文件 alien@localhost:~$ ls /usr/bin | tee ls.txt | grep zip funzip gpg-zip mzip preunzip prezip prezip-bin unzip unzipsfx zip zipcloak zipdetails zipgrep zipinfo zipnote zipsplit alien@localhost:~$ cat ls.txt [ 2to3 2to3-2.7 2to3-3.5 七、走进Shell DOS批处理教程 echo － 显示一行文本 echo展开 (字符)展开： 一个简单的字符序列”*”，通过展开， 你输入的字符，在 shell 对它起作用之前，会展开成为别的字符。 alien@localhost:~$ echo this is a test this is a test alien@localhost:~$ echo * app Calibre 书库 examples.desktop lazy_dog.txt ls-output-1.txt ls-output.txt ls.txt PycharmProjects sys test.txt VirtualBox VMs 公共的 模板 视频 图片 文档 下载 音乐 桌面 alien@localhost:~$ 关于通配符，看上面的介绍。 shell 在 echo 命 令被执行前把 * 展开成了另外的东西（在这里，就是在当前工作目录下的文件名字）当回车键被按下时，shell 在命令被执行前在命令行上自动展开任何符合条件的字符， 所以 echo 命令的实际参数并不是”*“，而是它展开后的结果。 路径名展开: 通配符所依赖的工作机制叫做路径名展开. alien@localhost:~$ ls app ls-output-1.txt sys 模板 下载 Calibre 书库 ls-output.txt test.txt 视频 音乐 examples.desktop ls.txt VirtualBox VMs 图片 桌面 lazy_dog.txt PycharmProjects 公共的 文档 alien@localhost:~$ echo ls* ls-output-1.txt ls-output.txt ls.txt alien@localhost:~$ echo *t lazy_dog.txt ls-output-1.txt ls-output.txt ls.txt test.txt 显示隐藏文件： # 不能包含以多个圆点开头的文件名 alien@localhost:~$ echo .[!.]?* .adobe .atom .bash_history .bash_logout .bashrc .bashrc.swl .bashrc.swm .bashrc.swn .bashrc.swo .bashrc.swp .cache .compiz .config .dbus .dmrc ... alien@localhost:~$ ls -d .[!.]?* .adobe .compiz .java .PyCharmCE2016.3 .atom .config .jupyter .python_history .bash_history .dbus .kingsoft .remarkable ... # 显示所有文件 alien@localhost:~$ ls -A .adobe .gnome .python_history app .gnupg .remarkable ... 算术表达式展开: alien@localhost:~$ echo $((2 + 2)) 4 alien@localhost:~$ echo $(($((5**2)) * 3)) 75 alien@localhost:~$ echo $(((5**2) * 3)) 75 算术表达式空格并不重要，表达式可以嵌套，只支持整数（全部是数字，不带小数点），但是能执行很多不同的操作。 操作符 说明 + 加 - 减 * 乘 / 除（但是记住，因为展开只是支持整数除法，所以结果是整数。） % 取余，只是简单的意味着，“余数” ** 取幂 花括号展开： alien@localhost:~$ echo Front-{A,B,C}-Back Front-A-Back Front-B-Back Front-C-Back alien@localhost:~$ echo Number_{1..5} Number_1 Number_2 Number_3 Number_4 Number_5 alien@localhost:~$ echo a{A{1,2},B{3,4}}b aA1b aA2b aB3b aB4b 括号展开模式可能包含一个开头部分叫做报头，一个结尾部分叫做附言。 alien@localhost:~$ mkdir Pics alien@localhost:~$ cd Pics/ alien@localhost:~/Pics$ mkdir {2007..2009}-0{1..9} {2007..2009}-{10..12} alien@localhost:~/Pics$ ls 2007-01 2007-05 2007-09 2008-01 2008-05 2008-09 2009-01 2009-05 2009-09 2007-02 2007-06 2007-10 2008-02 2008-06 2008-10 2009-02 2009-06 2009-10 2007-03 2007-07 2007-11 2008-03 2008-07 2008-11 2009-03 2009-07 2009-11 2007-04 2007-08 2007-12 2008-04 2008-08 2008-12 2009-04 2009-08 2009-12 参数展开： alien@localhost:~$ echo $USER alien # 查看有效的变量列表 alien@localhost:~$ printenv | less 命令替换 命令替换允许我们把一个命令的输出作为一个展开模式来使用： # 在不知道 cp 命令 完整路径名的情况下得到它的文件属性列表 alien@localhost:~$ ls -l $(which cp) -rwxr-xr-x 1 root root 151024 3月 3 2017 /bin/cp alien@localhost:~$ ls -l `which cp` -rwxr-xr-x 1 root root 151024 3月 3 2017 /bin/cp # 管道线的输出结果成为 file 命令的参数列表 alien@localhost:~$ file $(ls /usr/bin/* | grep zip) /usr/bin/funzip: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=06412c648a6927c4a14c751fe2412db3425ecd0f, stripped ... 引用--控制展开 \\是转义字符，经常在双引号中使用转义字符，来有选择地阻止展开。 # shell 利用单词分割删除掉 echo 命令的参数列表中多余的空格 alien@localhost:~$ echo this is a test this is a test # 参数展开把 $1 的值替换为一个空字符串 alien@localhost:~$ echo The total is $100.00 The total is 00.00 双引号中的文本都失去它们的特殊含义，单词分割被禁止，内嵌的空格也不会被当作界定符，它们成为参数的一部分，一对双引号里的内容就是一个参数的命令。 alien@localhost:~$ cat two\\ words.txt hhh alien@localhost:~$ cat two words.txt cat: two: 没有那个文件或目录 cat: words.txt: 没有那个文件或目录 alien@localhost:~$ cat \"two words.txt\" hhh alien@localhost:~$ cat two\\ words.txt hhh alien@localhost:~$ mv \"two words.txt\" two_words.txt 在双引号中，参数展开、算术表达式展开和命令替换仍然有效 alien@localhost:~$ echo \"$USER $((2+2)) $(cal)\" alien 4 九月 2018 日 一 二 三 四 五 六 1 2 3 4 5 6 7 8 .... # 38个参数 alien@localhost:~$ echo $(cal) 九月 2018 日 一 二 三 四 五 六 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # 只有一个参数 alien@localhost:~$ echo \"$(cal)\" 九月 2018 日 一 二 三 四 五 六 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 单引号禁止所有的展开 转义序列 含义 \\a 响铃（”警告”－导致计算机嘟嘟响） \\b 退格符 \\n 新的一行。在类 Unix 系统中，产生换行。 \\r 回车符 \\t 制表符 echo 命令带上 ‘-e’ 选项，能够解释转义序列。展开和引用在Linux系统中使用非常频繁，这是shell的重要特性 。 八、键盘高级操作技巧 clear － 清空屏幕 history － 显示历史列表内容 快捷键 移动光标： 按键 行动 Ctrl-a 移动光标到行首。 Ctrl-e 移动光标到行尾。 Ctrl-f 光标前移一个字符；和右箭头作用一样。 Ctrl-b 光标后移一个字符；和左箭头作用一样。 Alt-f 光标前移一个字。 Alt-b 光标后移一个字。 Ctrl-l 清空屏幕，移动光标到左上角。clear 命令完成同样的工作。 修改文本: 按键 行动 Ctrl-d 删除光标位置的字符。 Ctrl-t 光标位置的字符和光标前面的字符互换位置。 Alt-t 光标位置的字和其前面的字互换位置。 Alt-l 把从光标位置到字尾的字符转换成小写字母。 Alt-u 把从光标位置到字尾的字符转换成大写字母。 剪切和粘贴文本: 按键 行动 Ctrl-k 剪切从光标位置到行尾的文本。 Ctrl-u 剪切从光标位置到行首的文本。 Alt-d 剪切从光标位置到词尾的文本。 Alt-Backspace 剪切从光标位置到词头的文本。如果光标在一个单词的开头，剪切前一个单词。 Ctrl-y 把剪切环中的文本粘贴到光标位置。 利用历史命令： # `.bash_history` 的文件存放历史命令 alien@localhost:~$ ls .bash* .bash_history .bashrc .bashrc.swm .bashrc.swo .bash_logout .bashrc.swl .bashrc.swn .bashrc.swp alien@localhost:~$ history | less # 找出和/usr/bin这一目录相关的命令 alien@localhost:~$ history | grep /usr/bin 786 cd /usr/bin 793 cd /usr/bin 903 ls -l /usr/bin > ls-output.txt 933 ls -l /usr/bin >> ls-output.txt 2>&1 936 ls -l /usr/bin >> ls-output.txt 2>&1 937 ls -l /usr/bin >> ls-output-1.txt 2>&1 946 ls -l /usr/bin | less ... Ctrl-r:历史命令反向增量搜索，匹配到命令行按enter执行，Ctrl-j复制。 序列 行为 !! 重复最后一次执行的命令。可能按下上箭头按键和 enter 键更容易些。 !number 重复历史列表中第 number 行的命令。 !string 重复最近历史列表中，以这个字符串开头的命令。 !?string 重复最近历史列表中，包含这个字符串的命令。 九、权限 id – 显示用户身份号 chmod – 更改文件模式 umask – 设置默认的文件权限 su – 以另一个用户的身份来运行 shell sudo – 以另一个用户的身份来执行命令 chown – 更改文件所有者 chgrp – 更改文件组所有权 passwd – 更改用户密码 alien@localhost:~$ id uid=1000(alien) gid=1000(alien) 组=1000(alien),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare) 当用户创建帐户之后，系统会给用户分配一个号码，叫做用户 ID 或者 uid，这个 ID 映射到一个用户名。系统又会给这个用户分配一个原始的组 ID 或者是 gid，这个 gid 可能属于另外的组。 用户帐户 定义在/etc/passwd文件里面，用户组定义在/etc/group 文件里面。当用户帐户和用户组创建以后， 这些文件随着文件/etc/shadow的变动而修改，文件/etc/shadow包含了关于用户密码的信息。 对于每个用户帐号，文件/etc/passwd 定义了用户（登录）名、uid、gid、帐号的真实姓名、家目录 和登录 shell。 alien@localhost:~$ touch foo.txt alien@localhost:~$ ls -l foo.txt -rw-rw-r-- 1 alien alien 0 9月 18 16:04 foo.txt 文件类型： 属性 文件类型 - 一个普通文件 d 一个目录 l 一个符号链接。注意对于符号链接文件，剩余的文件属性总是\"rwxrwxrwx\"，而且都是 虚拟值。真正的文件属性是指符号链接所指向的文件的属性。 c 一个字符设备文件。这种文件类型是指按照字节流来处理数据的设备。 比如说终端机或者调制解调器 b 一个块设备文件。这种文件类型是指按照数据块来处理数据的设备，例如一个硬盘或者 CD-ROM 盘。 后面九个字符代表着文件所有者、文件组所有者和其他人的读、写和执行权限。 属性 文件 目录 r 允许打开并读取文件内容。 允许列出目录中的内容，前提是目录必须设置了可执行属性（x）。 w 允许写入文件内容或截断文件。但是不允许对文件进行重命名或删除，重命名或删除是由目录的属性决定的。 允许在目录下新建、删除或重命名文件，前提是目录必须设置了可执行属性（x）。 x 允许将文件作为程序来执行，使用脚本语言编写的程序必须设置为可读才能被执行。 允许进入目录，例如：cd directory 。 chmod － 更改文件权限 chmod 命令支持两种不同的方法来改变文件模式：八进制数字表示法或 符号表示法。 八进制数字表示法： Octal Binary File Mode 0 000 --- 1 001 --x 2 010 -w- 3 011 -wx 4 100 r-- 5 101 r-x 6 110 rw- 7 111 rwx alien@localhost:~$ ls -l foo.txt -rw-rw-r-- 1 alien alien 0 9月 18 16:04 foo.txt alien@localhost:~$ chmod 777 foo.txt alien@localhost:~$ ls -l foo.txt -rwxrwxrwx 1 alien alien 0 9月 18 16:04 foo.txt # u+rw、g-w等等 alien@localhost:~$ chmod g-rwx foo.txt alien@localhost:~$ ls -l foo.txt -rwx---rwx 1 alien alien 0 9月 18 16:04 foo.txt 符号表示法： 如果没有指定字符，则假定使用”all”。 u \"user\"的简写，意思是文件或目录的所有者。 g 用户组。 o \"others\"的简写，意思是其他所有的人。 a \"all\"的简写，是\"u\", \"g\"和“o”三者的联合。 umask － 设置默认权限 Original file mode --- rw- rw- rw- Mask 000 000 000 010 Result --- rw- rw- r-- 掩码是八进制，转换为二进制后，若出现一个数字1，则删除文件模式中和这个1在相同位置的属性 更改身份 注销系统并以其他用户身份重新登录系统。 使用 su 命令。 使用 sudo 命令。 su 命令用来以另一个用户的身份来启动 shell：su [-[l]] [user]，如果包含”-l”或者\"-\"选项，那么会为指定用户启动一个需要登录的 shell，并且工作目录会更改到这个用户的家目录。如果不指定用户，那么就假定是超级用户。 alien@localhost:~$ su 密码： root@localhost:/home/alien# exit exit alien@localhost:~$ su -l 密码： root@localhost:~# exit 注销 alien@localhost:~$ su - 密码： root@localhost:~# exit 注销 管理员能够配置 sudo 命令，从而允许一个普通用户以不同的身份（通常是超级用户），通过一种非常可控的方式 来执行命令。 sudo 命令不要求超级用户的密码，使用 sudo 命令时，用户使用他/她自己的密码 来认证。 # 查看sudo 命令可以授予哪些权限 alien@localhost:~$ sudo -l 匹配 %2$s 上 %1$s 的默认条目： env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin 用户 alien 可以在 localhost 上运行以下命令： (ALL : ALL) ALL chown － 更改文件所有者和用户组 alien@localhost:~$ su 密码： root@localhost:/home/alien# chown [owner][:[group]] file... 第一个参数更改文件所有者和/或文件用户组，第二个参数是文件或文件夹 参数 结果 bob 把文件所有者从当前属主更改为用户 bob。 bob:users 把文件所有者改为用户 bob，文件用户组改为用户组 users。 :admins 把文件用户组改为组 admins，文件所有者不变。 bob: 文件所有者改为用户 bob，文件用户组改为用户 bob 登录系统时所属的用户组。 chgrp － 更改用户组所有权 更改用户密码 passwd [user] 十、进程 ps – 报告当前进程快照 top – 显示任务 jobs – 列出活跃的任务 bg – 把一个任务放到后台执行 fg – 把一个任务放到前台执行 kill – 给一个进程发送信号 killall – 杀死指定名字的进程 shutdown – 关机或重启系统 ps查看进程 alien@localhost:~$ ps PID TTY TIME CMD 27867 pts/3 00:00:00 bash 28091 pts/3 00:00:00 ps TTY 是指进程的控制终端默，TIME 字段表示 进程所消耗的 CPU 时间数量。认情况下，ps 不会显示很多进程信息，只是列出与当前终端会话相关的进程. alien@localhost:~$ ps x PID TTY STAT TIME COMMAND 1148 ? Ss 0:00 /lib/systemd/systemd --user 1150 ? S 0:00 (sd-pam) ... STAT 是 “state” 的简写，它揭示了进程当前状态。进程状态信息之后，可能还跟随其他的字符。这表示各种外来进程的特性。 状态 含义 R 运行中。这意味着，进程正在运行或准备运行。 S 正在睡眠。进程没有运行，而是，正在等待一个事件， 比如说，一个按键或者网络分组。 D 不可中断睡眠。进程正在等待 I/O，比方说，一个磁盘驱动器的 I/O。 T 已停止. 已经指示进程停止运行。稍后介绍更多。 Z 一个死进程或“僵尸”进程。这是一个已经终止的子进程，但是它的父进程还没有清空它。 （父进程没有把子进程从进程表中删除） 一个高优先级进程。这可能会授予一个进程更多重要的资源，给它更多的 CPU 时间。 进程的这种属性叫做 niceness。具有高优先级的进程据说是不好的（less nice）， 因为它占用了比较多的 CPU 时间，这样就给其它进程留下很少时间。 N 低优先级进程。 一个低优先级进程（一个“nice”进程）只有当其它高优先级进程被服务了之后，才会得到处理器时间。 # 这个选项组合，能够显示属于每个用户的进程信息 alien@localhost:~$ ps aux USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 1 0.0 0.1 185460 4748 ? Ss 11:25 0:01 /sbin/init spla root 2 0.0 0.0 0 0 ? S 11:25 0:00 [kthreadd] ... 标题 含义 USER 用户 ID. 进程的所有者。 %CPU 以百分比表示的 CPU 使用率 %MEM 以百分比表示的内存使用率 VSZ 虚拟内存大小 RSS 进程占用的物理内存的大小，以千字节为单位。 START 进程启动的时间。若它的值超过24小时，则用天表示。 top动态查看进程 # 默认情况下，每三秒钟更新一次,top 显示结果由两部分组成： 最上面是系统概要，下面是进程列表，以 CPU 的使用率排序。 alien@localhost:~$ top top - 17:24:44 up 5:59, 1 user, load average: 0.56, 0.81, 0.63 Tasks: 222 total, 1 running, 221 sleeping, 0 stopped, 0 zombie %Cpu(s): 9.3 us, 2.7 sy, 0.0 ni, 87.8 id, 0.2 wa, 0.0 hi, 0.0 si, 0.0 st KiB Mem : 3949784 total, 1227196 free, 1562828 used, 1159760 buff/cache KiB Swap: 4102140 total, 3583672 free, 518468 used. 1768020 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 870 root 20 0 413888 53400 36872 S 10.3 1.4 12:43.43 Xorg ... 系统概要含义： 行号 字段 意义 1 top 程序名。 14:59:20 当前时间。 up 6:30 这是正常运行时间。它是计算机从上次启动到现在所运行的时间。 在这个例子里，系统已经运行了六个半小时。 2 users 有两个用户登录系统。 load average: 加载平均值是指，等待运行的进程数目，也就是说，处于可以运行状态并共享 CPU 的进程个数。 这里展示了三个数值，每个数值对应不同的时间段。第一个是最后60秒的平均值， 下一个是前5分钟的平均值，最后一个是前15分钟的平均值。若平均值低于1.0，则指示计算机 工作不忙碌。 2 Tasks: 总结了进程数目和这些进程的各种状态。 3 Cpu(s): 这一行描述了 CPU 正在进行的活动的特性。 0.7%us 0.7% 的 CPU 被用于用户进程。这意味着进程在内核之外。 1.0%sy 1.0%的 CPU 时间被用于系统（内核）进程。 0.0%ni 0.0%的 CPU 时间被用于\"nice\"（低优先级）进程。 98.3%id 98.3%的 CPU 时间是空闲的。 0.0%wa 0.0%的 CPU 时间来等待 I/O。 4 Mem: 展示物理内存的使用情况。 5 Swap: 展示交换分区（虚拟内存）的使用情况。 top 程序接受一系列从键盘输入的命令。两个最有趣的命令是 h 和 q。h，显示程序的帮助屏幕，q， 退出 top 程序。 控制进程 在一个终端中，输入 Ctrl-c， INT（Interrupt,中断）信号，中断一个程序 把一个进程放置到后台(执行) alien@localhost:~$ xlogo & [1] 30167 alien@localhost:~$ ps PID TTY TIME CMD 29939 pts/2 00:00:00 bash 30167 pts/2 00:00:00 xlogo 30169 pts/2 00:00:00 ps 执行 jobs 命令，列出从我们终端中启动了的任务。 alien@localhost:~$ xlogo & [1] 30691 alien@localhost:~$ jobs [1]+ 运行中 xlogo & alien@localhost:~$ fg %1 xlogo ^C alien@localhost:~$ 进程返回到前台fg 停止一个进程CTRL+Z， TSTP（Terminal Stop,终端停止）信号，类似于暂停 为什么要从命令行启动一个图形界面程序呢？有两个原因。第一个，你想要启动的程序，可能 没有在窗口管理器的菜单中列出来（比方说 xlogo）。第二个，从命令行启动一个程序， 你能够看到一些错误信息，如果从图形界面中运行程序的话，这些信息是不可见的。 kill杀死一个进程 alien@localhost:~$ xlogo & [1] 31254 alien@localhost:~$ kill %1 kill [-signal] PID...：如果在命令行中没有指定信号，那么默认情况下，发送 TERM（Terminate，终止）信号。kill 命令被经常 用来发送以下命令： 编号 名字 含义 1 HUP 挂起（Hangup）。这是美好往昔的残留部分，那时候终端机通过电话线和调制解调器连接到 远端的计算机。这个信号被用来告诉程序，控制的终端机已经“挂断”。 通过关闭一个终端会话，可以展示这个信号的作用。在当前终端运行的前台程序将会收到这个信号并终止。许多守护进程也使用这个信号，来重新初始化。这意味着，当一个守护进程收到这个信号后， 这个进程会重新启动，并且重新读取它的配置文件。Apache 网络服务器守护进程就是一个例子。 2 INT 中断。实现和 Ctrl-c 一样的功能，由终端发送。通常，它会终止一个程序。 9 KILL 杀死。这个信号很特别。尽管程序可能会选择不同的方式来处理发送给它的 信号，其中也包含忽略信号，但是 KILL 信号从不被发送到目标程序。而是内核立即终止 这个进程。当一个进程以这种方式终止的时候，它没有机会去做些“清理”工作，或者是保存工作。 因为这个原因，把 KILL 信号看作最后一招，当其它终止信号失败后，再使用它。 15 TERM 终止。这是 kill 命令发送的默认信号。如果程序仍然“活着”，可以接受信号，那么 这个它会终止。 18 CONT 继续。在一个停止信号后，这个信号会恢复进程的运行。 19 STOP 停止。这个信号导致进程停止运行，而不是终止。像 KILL 信号，它不被 发送到目标进程，因此它不能被忽略。 信号既可以用号码，也可以用名字来指定，可以用 jobspec（例如，“％1”）来代替 PID。 其它常用信号： 编号 名字 含义 3 QUIT 退出 11 SEGV 段错误(Segmentation Violation)。如果一个程序非法使用内存，就会发送这个信号。也就是说， 程序试图写入内存，而这个内存空间是不允许此程序写入的。 20 TSTP 终端停止(Terminal Stop)。当按下 Ctrl-z 组合键后，终端发送这个信号。不像 STOP 信号， TSTP 信号由目标进程接收，且可能被忽略。 28 WINCH 改变窗口大小(Window Change)。当改变窗口大小时，系统会发送这个信号。 一些程序，像 top 和 less 程序会响应这个信号，按照新窗口的尺寸，刷新显示的内容。 完整的信号列表： alien@localhost:~$ kill -l 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR1 11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM 16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP 21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ 26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR 31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+3 38) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+8 43) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-7 58) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-2 63) SIGRTMAX-1 64) SIGRTMAX killall给多个进程发送信号 killall [-u user] [-signal] name... alien@localhost:~$ xlogo & [1] 31816 alien@localhost:~$ xlogo & [2] 31817 alien@localhost:~$ killall xlogo alien@localhost:~$ 更多和进程相关的命令 命令名 命令描述 pstree 输出一个树型结构的进程列表(processtree)，这个列表展示了进程间父/子关系。 vmstat 输出一个系统资源使用快照，包括内存，交换分区和磁盘 I/O。 为了看到连续的显示结果，则在命令名后加上更新操作延时的时间（以秒为单位）。例如，“vmstat 5”。 ，按下 Ctrl-c 组合键, 终止输出。 xload 一个图形界面程序，可以画出系统负载随时间变化的图形。 tload terminal load与 xload 程序相似，但是在终端中画出图形。使用 Ctrl-c，来终止输出。 至此，Shell算是了解了一些基本概念，路还很长，后续继续更新... Copyright © 2018 S all right reserved，powered by Gitbook该文件修订时间： 2018-09-18 21:49:11 "},"post/02-config-and-environments.html":{"url":"post/02-config-and-environments.html","title":"Shell环境","summary":"了解一下shell环境","keywords":"","body":"shell 环境 大多数程序用配置文件来存储程序设置， 一些程序会根据环境变量来调整他们的行为。shell 在环境中存储了两种基本类型的数据：Shell 变量是 bash 存放的少量数据，剩下的都是 环境变量。另外还有别名和 shell 函数。 printenv - 打印部分或所有的环境变量 set - 设置 shell 选项 export — 导出环境变量，让随后执行的程序知道。 alias - 创建命令别名 检查环境变量 查看环境变量： 内建命令 set：可以 显示 shell 或环境变量 printenv程序：只是显示环境变量，$ printenv | less # printenv 命令也能够列出特定变量的数值 alien@localhost:~$ printenv USER alien # echo 命令来查看一个变量的内容 alien@localhost:~$ echo $HOME /home/alien 别名无法通过使用 set 或 printenv 来查看。 用不带参数的 alias 来查看别名: alien@localhost:~$ alias alias alert='notify-send --urgency=low -i \"$([ $? = 0 ] && echo terminal || echo error)\" \"$(history|tail -n1|sed -e '\\''s/^\\s*[0-9]\\+\\s*//;s/[;&|]\\s*alert$//'\\'')\"' alias egrep='egrep --color=auto' alias fgrep='fgrep --color=auto' alias grep='grep --color=auto' alias l='ls -CF' alias la='ls -A' alias ll='ls -alF' alias ls='ls --color=auto' 环境变量 内容 DISPLAY 如果你正在运行图形界面环境，那么这个变量就是你显示器的名字。通常，它是 \":0\"， 意思是由 X 产生的第一个显示器。 EDITOR 文本编辑器的名字。 SHELL shell 程序的名字。 HOME 用户家目录。 LANG 定义了字符集以及语言编码方式。 OLD_PWD 先前的工作目录。 PAGER 页输出程序的名字。这经常设置为/usr/bin/less。 PATH 由冒号分开的目录列表，当你输入可执行程序名后，会搜索这个目录列表。 PS1 Prompt String 1. 这个定义了你的 shell 提示符的内容。随后我们可以看到，这个变量 内容可以全面地定制。 PWD 当前工作目录。 TERM 终端类型名。类 Unix 的系统支持许多终端协议；这个变量设置你的终端仿真器所用的协议。 TZ 指定你所在的时区。大多数类 Unix 的系统按照协调时间时 (UTC) 来维护计算机内部的时钟 ，然后应用一个由这个变量指定的偏差来显示本地时间。 USER 你的用户名 建立shell 环境 登录 shell 会读取一个或多个启动文件----虚拟控制台会话： 文件 内容 /etc/profile 应用于所有用户的全局配置脚本。 ~/.bash_profile 用户个人的启动文件。可以用来扩展或重写全局配置脚本中的设置。 ~/.bash_login 如果文件 ~/.bash_profile 没有找到，bash 会尝试读取这个脚本。 ~/.profile 如果文件 ~/.bash_profile 或文件 ~/.bash_login 都没有找到，bash 会试图读取这个文件。 这是基于 Debian 发行版的默认设置，比方说 Ubuntu。 非登录 shell 会话会读取以下启动文件----GUI： 文件 内容 /etc/bash.bashrc 应用于所有用户的全局配置文件。 ~/.bashrc 用户个人的启动文件。可以用来扩展或重写全局配置脚本中的设置。 除了读取以上启动文件之外，非登录 shell 会话也会继承它们父进程的环境设置，通常是一个登录 shell。 alien@localhost:~$ cat .bashrc # ~/.bashrc: executed by bash(1) for non-login shells. # see /usr/share/doc/bash/examples/startup-files (in the package bash-doc) # for examples # If not running interactively, don't do anything case $- in *i*) ;; *) return;; esac ... PATH 变量经常（但不总是，依赖于发行版）在 /etc/profile 启动文件中设置，通过这些代码： # 目录 $HOME/bin 就添加到了命令搜索目录列表中 PATH=$PATH:$HOME/bin Tips: 把文本附加到一个变量值的末尾 alien@localhost:~$ foo=\"This is some\" alien@localhost:~$ echo $foo This is some alien@localhost:~$ foo=\"$foo text.\";echo $foo This is some text. export PATH：这个 export 命令告诉 shell 让这个 shell 的子进程可以使用 PATH 变量的内容。 修改 shell 环境 添加目录到你的 PATH 变量或者是定义额外的环境变量，要把这些更改放置到 .bash_profile 文件中（或者其替代文件中，根据不同的发行版。例如，Ubuntu 使用 .profile 文件）。 对于其它的更改，要放到 .bashrc 文件中。 # 别名 alien@localhost:~$ ll 总用量 332 drwxrwxrwx 35 alien alien 4096 9月 18 22:32 ./ drwxr-xr-x 3 root root 4096 11月 29 2017 ../ ... # 强迫 bash 重新读取修改过的 .bashrc 文件，使用下面的命令： source .bashrc 自定义Shell提示符 提示符是由一个环境变量定义的，叫做 PS1（是“prompt string one” 的简写） alien@localhost:~$ echo $PS1 \\[\\e]0;\\u@\\h: \\w\\a\\]${debian_chroot:+($debian_chroot)}\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\$ 具体的修改详见：https://billie66.github.io/TLCL/book/chap14.html ，这方面不需要了解。 Copyright © 2018 S all right reserved，powered by Gitbook该文件修订时间： 2018-09-18 23:05:19 "},"post/03-task-and-tools-1.html":{"url":"post/03-task-and-tools-1.html","title":"常见任务和基本工具(上篇)","summary":"Linux入门必备","keywords":"","body":"[TOC] 一、软件包管理 主要的包管理系统家族： 包管理系统 发行版 (部分列表) Debian Style (.deb) Debian, Ubuntu, Xandros, Linspire Red Hat Style (.rpm) Fedora, CentOS, Red Hat Enterprise Linux, OpenSUSE, Mandriva, PCLinuxOS 如果一个软件包需要一些共享的资源，如一个动态链接库，它就被称作有一个依赖。软件包管理系统通常由两种工具类型组成：底层工具用来处理这些任务，比方说安装和删除软件包文件；上层工具，完成元数据搜索和依赖解析。 包管理工具： 发行版 底层工具 上层工具 Debian-Style dpkg apt-get, aptitude Fedora, Red Hat Enterprise Linux, CentOS rpm yum 使用上层工具来搜索资源库元数据，可以根据软件包的名字和说明来定位它： 风格 命令 Debian apt-get update; apt-cache search search_string Red Hat yum search search_string 上层工具允许从一个资源库中下载一个软件包，并经过完全依赖解析来安装它： 风格 命令 Debian apt-get update; apt-get install package_name Red Hat yum install package_name 底层软件包安装命令： 风格 命令 Debian dpkg --install package_file Red Hat rpm -i package_file 使用上层工具来卸载软件： 风格 命令 Debian apt-get remove package_name Red Hat yum erase package_name 上层工具软件包更新命令： 风格 命令 Debian apt-get update; apt-get upgrade Red Hat yum update 底层软件包升级命令： 风格 命令 Debian dpkg --install package_file Red Hat rpm -U package_file 列出所安装的软件包： 风格 命令 Debian dpkg --list Red Hat rpm -qa 底端工具可以用来显示是否安装了一个指定的软件包： 风格 命令 Debian dpkg --status package_name Red Hat rpm -q package_name 查看软件包信息： 风格 命令 Debian apt-cache show package_name Red Hat yum info package_name 确定哪个软件包对所安装的某个特殊文件负责： 风格 命令 Debian dpkg --search file_name Red Hat rpm -qf file_name 二、存储媒介 mount – 挂载一个文件系统 umount – 卸载一个文件系统 fsck – 检查和修复一个文件系统 fdisk – 分区表控制器 mkfs – 创建文件系统 fdformat – 格式化一张软盘 dd — 把面向块的数据直接写入设备 genisoimage (mkisofs) – 创建一个 ISO 9660的映像文件 wodim (cdrecord) – 把数据写入光存储媒介 md5sum – 计算 MD5检验码 挂载和卸载存储设备 管理存储设备的第一步是把设备连接到文件系统树中，即挂载。有一个叫做/etc/fstab的文件可以列出系统启动时要挂载的设备（典型地，硬盘分区）。 Fedora 7系统的/etc/fstab 文件实例： LABEL=/12 / ext3 defaults 1 1 LABEL=/home /home ext3 defaults 1 2 LABEL=/boot /boot ext3 defaults 1 2 字段说明： 字段 内容 说明 1 设备名 传统上，这个字段包含与物理设备相关联的设备文件的实际名字，比如说/dev/hda1（第一个 IDE 通道上第一个主设备分区）。然而今天的计算机，有很多热插拔设备（像 USB 驱动设备），许多 现代的 Linux 发行版用一个文本标签和设备相关联。当这个设备连接到系统中时， 这个标签（当储存媒介格式化时，这个标签会被添加到存储媒介中）会被操作系统读取。 那样的话，不管赋给实际物理设备哪个设备文件，这个设备仍然能被系统正确地识别。 2 挂载点 设备所连接到的文件系统树的目录。 3 文件系统类型 Linux 允许挂载许多文件系统类型。大多数本地的 Linux 文件系统是 ext3， 但是也支持很多其它的，比方说 FAT16 (msdos), FAT32 (vfat)，NTFS (ntfs)，CD-ROM (iso9660)，等等。 4 选项 文件系统可以通过各种各样的选项来挂载。有可能，例如，挂载只读的文件系统， 或者挂载阻止执行任何程序的文件系统（一个有用的安全特性，避免删除媒介。） 5 频率 一位数字，指定是否和在什么时间用 dump 命令来备份一个文件系统。 6 次序 一位数字，指定 fsck 命令按照什么次序来检查文件系统。 查看挂载的文件系统列表 # mount 命令被用来挂载文件系统 # 设备 on 挂载点 type 文件系统类型（选项） alien@localhost:~$ mount sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime) proc on /proc type proc (rw,nosuid,nodev,noexec,relatime) udev on /dev type devtmpfs (rw,nosuid,relatime,size=1947612k,nr_inodes=486903,mode=755) /dev/hdc on /media/live-1.0.10-8 type iso9660 (ro,noexec,nosuid, nodev,uid=500) ... # umount卸载文件系统 alien@localhost:~$ su 密码： root@localhost:/home/alien# umount /dev/hdc # 把设备挂载到了一个目录 mkdir /mnt/cdrom mount -t iso9660 /dev/hdc /mnt/cdrom # 卸载设备 umount /dev/hdc tips：打印机缓存是一个包含一些 RAM 内存 的设备，位于计算机和打印机之间。通过打印机缓存，计算机把要打印的结果发送到这个缓存区， 数据会迅速地存储到这个 RAM 中，这样计算机就能回去工作，而不用等待。与此同时，打印机缓存将会 以打印机可接受的速度把缓存中的数据缓慢地输出给打印机。 确定设备名称 # 列出目录/dev（所有设备的住所） alien@localhost:~$ ls /dev autofs i2c-8 sda tty21 tty55 ttyS3 block initctl sda1 tty22 tty56 ttyS30 bsg input sda10 tty23 tty57 ttyS31 btrfs-control kmsg sda11 tty24 tty58 ttyS4 ... Linux 存储设备名称: 模式 设备 /dev/fd* 软盘驱动器 /dev/hd* 老系统中的 IDE(PATA)磁盘。典型的主板包含两个 IDE 连接器或者是通道，每个连接器 带有一根缆线，每根缆线上有两个硬盘驱动器连接点。缆线上的第一个驱动器叫做主设备， 第二个叫做从设备。设备名称这样安排，/dev/hdb 是指第一通道上的主设备名；/dev/hdb 是第一通道上的从设备名；/dev/hdc 是第二通道上的主设备名，等等。末尾的数字表示 硬盘驱动器上的分区。例如，/dev/hda1是指系统中第一硬盘驱动器上的第一个分区，而 /dev/hda 则是指整个硬盘驱动器。 /dev/lp* 打印机 /dev/sd* SCSI 磁盘。在最近的 Linux 系统中，内核把所有类似于磁盘的设备（包括 PATA/SATA 硬盘， 闪存，和 USB 存储设备，比如说可移动的音乐播放器和数码相机）看作 SCSI 磁盘。 剩下的命名系统类似于上述所描述的旧的/dev/hd*命名方案。 /dev/sr* 光盘（CD/DVD 读取器和烧写器） 创建新的文件系统 假设我们使用一个16MB 闪存备，名称是/dev/sdb 指整个设备，/dev/sdb1是这个设备的第一分区，fdisk 命令操作分区： # 操作分区 sudo fdisk /dev/sdb # 创建一个新的文件系统 sudo mkfs -t ext3 /dev/sdb1 # 重新格式化为它最初的 FAT32文件 系统 sudo mkfs -t vfat /dev/sdb1 测试和修复文件系统 # 检查我们的闪存驱动器 sudo fsck /dev/sdb1 格式化软盘 使用 fdformat 程序，同时指定软盘设备名称（通常为/dev/fd0）： sudo fdformat /dev/fd0 # 通过 mkfs 命令，给这个软盘创建一个 FAT 文件系统 sudo mkfs -t msdos /dev/fd0 直接把数据移入/出设备 dd 程序把磁盘驱动器简单地看成一个数据块大集合，可以克隆设备： dd if=input_file of=output_file [bs=block_size [count=blocks]] # 把第一个驱动器中的所有数据复制到第二个 驱动器中。 dd if=/dev/sdb of=/dev/sdc # 如果只有第一个驱动器被连接到计算机上，我们可以把它的内容 # 复制到一个普通文件中供 以后恢复或复制数据： dd if=/dev/sdb of=flash_drive.img 创建 CD-ROM 映像 首先，构建一个 iso 映像文件， 这就是一个 CD-ROM 的文件系统映像 # 适用于 DVD 光盘, 对于音频 CD，看一下 cdrdao 命令 dd if=/dev/cdrom of=ubuntu.iso 创建一个包含目录内容的 iso 映像文件，我们使用 genisoimage 程序: genisoimage -o cd-rom.iso -R -J ~/cd-rom-files “-R”选项添加元数据为 Rock Ridge 扩展，这允许使用长文件名和 POSIX 风格的文件权限。 同样地，这个”-J”选项使 Joliet 扩展生效，这样 Windows 中就支持长文件名了。 第二步，把这个映像文件写入到 CD-ROM 媒介中。 # 直接挂载一个 ISO 镜像 mkdir /mnt/iso_image mount -t iso9660 -o loop image.iso /mnt/iso_image # 清除一张可重写入的 CD-ROM wodim dev=/dev/cdrw blank=fast # 写入镜像 wodim dev=/dev/cdrw image.iso checksum 文件： iso 映像文件的贡献者也会提供 一个 checksum 文件，它是一个神奇的数学运算的计算结果，这个数学计算会产生一个能表示目标文件内容的数字。生成 checksum 数字的最常见方法是使用 md5sum 程序。 md5sum image.iso 34e354760f9bb7fbf85c96f6a3f94ece image.iso 这就可以验证我们下载的镜像和发行商提供的镜像是否一致。如检验映像文件 dvd-image.iso 以及 DVD 光驱中磁盘 /dev/dvd 文件的完整性： md5sum dvd-image.iso; dd if=/dev/dvd bs=2048 count=$(( $(stat -c \"%s\" dvd-image.iso) / 2048 )) | md5sum 三、网络系统 ping - 发送 ICMP ECHO_REQUEST 数据包到网络主机 traceroute - 打印到一台网络主机的路由数据包 netstat - 打印网络连接，路由表，接口统计数据，伪装连接，和多路广播成员 ftp - 因特网文件传输程序 wget - 非交互式网络下载器 ssh - OpenSSH SSH 客户端（远程登录程序） 检查和监测网络 一个成功执行的“ping”命令会意味着网络的各个部件（网卡，电缆，路由，网关） 都处于正常的工作状态。 traceroute 程序（一些系统使用相似的 tracepath 程序来代替）会显示从本地到指定主机 要经过的所有“跳数”的网络流量列表。 alien@localhost:~ $ traceroute slashdot.org traceroute to slashdot.org (216.105.38.15), 30 hops max, 60 byte packets 1 10.35.0.1 (10.35.0.1) 43.175 ms 71.185 ms 71.203 ms 2 10.0.5.185 (10.0.5.185) 71.196 ms 71.165 ms 71.134 ms 3 10.0.8.5 (10.0.8.5) 71.052 ms 10.0.6.5 (10.0.6.5) 70.984 ms 10.0.8.5 (10.0.8.5) 70.978 ms ... 28 * * * 29 * * * 30 * * * 一共经由30个路由器，对于那些 提供标识信息的路由器，我们能看到它们的主机名，IP 地址和性能数据，这些数据包括三次从本地到 此路由器的往返时间样本。对于那些没有提供标识信息的路由器（由于路由器配置，网络拥塞，防火墙等 方面的原因），我们会看到几个星号，正如行中所示。 netstat 程序被用来检查各种各样的网络设置和统计数据： # 使用“-ie”选项，我们能够查看系统中的网络接口 alien@localhost:~ $ netstat -ie Kernel Interface table enp7s0 Link encap:以太网 硬件地址 74:e6:e2:41:f6:62 UP BROADCAST MULTICAST MTU:1500 跃点数:1 接收数据包:689500 错误:0 丢弃:0 过载:0 帧数:0 发送数据包:156502 错误:0 丢弃:0 过载:0 载波:0 碰撞:0 发送队列长度:1000 接收字节:300138422 (300.1 MB) 发送字节:23781675 (23.7 MB) ... 其中enp7s0是一个网络接口，lo是内部回环网络接口，它是一个虚拟接口，系统用它来自言自语。 上图使用这个“-r”选项会显示内核的网络路由表。这展示了系统是如何配置网络之间发送数据包的。172.16.0.0是目的地，IP 地址以零结尾是指网络，这个目的地意味着局域网中的任何一台主机； Gateway， 是网关（路由器）的名字或 IP 地址，用它来连接当前的主机和目的地的网络。 目的地 default。指的是发往任何表上没有列出的目的地网络的流量。 网络中传输文件 ftp： 命令 意思 ftp fileserver 唤醒 ftp 程序，让它连接到 FTP 服务器，fileserver。 anonymous 登录名。输入登录名后，将出现一个密码提示。一些服务器将会接受空密码， 其它一些则会要求一个邮件地址形式的密码。如果是这种情况，试着输入 “user@example.com”。 cd pub/cd_images/Ubuntu-8.04 跳转到远端系统中，要下载文件所在的目录下， 注意在大多数匿名的 FTP 服务器中，支持公共下载的文件都能在目录 pub 下找到 ls 列出远端系统中的目录。 lcd Desktop 跳转到本地系统中的 ~/Desktop 目录下。在实例中，ftp 程序在工作目录 ~ 下被唤醒。 这个命令把工作目录改为 ~/Desktop get ubuntu-8.04-desktop-i386.iso 告诉远端系统传送文件到本地。因为本地系统的工作目录 已经更改到了 ~/Desktop，所以文件会被下载到此目录。 bye 退出远端服务器，结束 ftp 程序会话。也可以使用命令 quit 和 exit。 lftp - 更好的 ftp： 虽然 lftp 工作起来与传统的 ftp 程序很相似，但是它带有额外的便捷特性，包括 多协议支持（包括 HTTP），若下载失败会自动地重新下载，后台处理，用 tab 按键来补全路径名，还有很多。 wget： 不只能下载单个文件，多个文件，甚至整个网站都能下载，这个程序的许多选项允许 wget 递归地下载，在后台下载文件（你退出后仍在下载），能完成未下载 全的文件。 与远程主机安全通信 ssh（Secure Shell）：它要认证远端主机是否为它 所知道的那台主机（这样就阻止了所谓的“中间人”的攻击），其次，它加密了本地与远程主机之间 所有的通讯信息。 SSH 由两部分组成。SSH 服务端运行在远端主机上，在端口 22 上监听收到的外部连接，而 SSH 客户端用在本地系统中，用来和远端服务器通信。 为了能让系统接受远端的连接，它必须安装 OpenSSH-server 软件包，它必须允许在 TCP 端口 22 上接收网络连接。 scp 和 sftp： OpenSSH 软件包也包含两个程序，scp（安全复制）被用来复制文件，与熟悉的 cp 程序非常相似。 # 主机名后面跟\":\" scp bob@remote-sys:./document.txt ./ sftp:任何一台能用 SSH 客户端连接的远端机器，也可当作类似于 FTP 的服务器来使用. Windows 中的 SSH 客户：PuTTY 四、查找文件 locate – 通过名字来查找文件 find – 在一个目录层次结构中搜索文件 xargs – 从标准输入生成和执行命令行 touch – 更改文件时间 stat – 显示文件或文件系统状态 locate - 查找文件的简单方法 find - 查找文件的复杂方式 locate 程序只能依据文件名来查找文件，而 find 程序能基于各种各样的属性 搜索一个给定目录（以及它的子目录），来查找文件。 上面find ~将产生一张很大的列表。 # wc 程序来计算出文件的数量 alien@localhost:~ $ sudo find ~ | wc -l 76602 # 文件数 alien@localhost:~ $ sudo find ~ -type f | wc -l 67531 # 目录数 alien@localhost:~ $ sudo find ~ -type d | wc -l 8899 文件类型： 文件类型 描述 b 块特殊设备文件 c 字符特殊设备文件 d 目录 f 普通文件 l 符号链接 # 限定名字和大小 alien@localhost:~ $ sudo find ~ -type f -name \"*.png\" -size +1k | wc -l 5409 大小单位： 字符 单位 b 512 个字节块。如果没有指定单位，则这是默认值。 c 字节 w 两个字节的字 k 千字节(1024个字节单位) M 兆字节(1048576个字节单位) G 千兆字节(1073741824个字节单位) find常用测试条件： 测试条件 描述 -cmin n 匹配内容或属性最后修改时间正好在 n 分钟之前的文件或目录。 指定少于 n 分钟之前，使用 -n，指定多于 n 分钟之前，使用 +n。 -cnewer file 匹配内容或属性最后修改时间晚于 file 的文件或目录。 -ctime n 匹配内容和属性最后修改时间在 n*24小时之前的文件和目录。 -empty 匹配空文件和目录。 -group name 匹配属于一个组的文件或目录。组可以用组名或组 ID 来表示。 -iname pattern 就像-name 测试条件，但是不区分大小写。 -inum n 匹配 inode 号是 n的文件。这对于找到某个特殊 inode 的所有硬链接很有帮助。 -mmin n 匹配内容被修改于 n 分钟之前的文件或目录。 -mtime n 匹配的文件或目录的内容被修改于 n*24小时之前。 -name pattern 用指定的通配符模式匹配的文件和目录。 -newer file 匹配内容晚于指定的文件的文件和目录。这在编写执行备份的 shell 脚本的时候很有帮。 每次你制作一个备份，更新文件（比如说日志），然后使用 find 命令来判断哪些文件自从上一次更新之后被更改了。 -nouser 匹配不属于一个有效用户的文件和目录。这可以用来查找 属于被删除的帐户的文件或监测攻击行为。 -nogroup 匹配不属于一个有效的组的文件和目录。 -perm mode 匹配权限已经设置为指定的 mode的文件或目录。mode 可以用 八进制或符号表示法。 -samefile name 类似于-inum 测试条件。匹配和文件 name 享有同样 inode 号的文件。 -size n 匹配大小为 n 的文件 -type c 匹配文件类型是 c 的文件。 -user name 匹配属于某个用户的文件或目录。这个用户可以通过用户名或用户 ID 来表示。 操作符： find ~ \\( -type f -not -perm 0600 \\) -or \\( -type d -not -perm 0700 \\) 操作符 描述 -and 如果操作符两边的测试条件都是真，则匹配。可以简写为 -a。 注意若没有使用操作符，则默认使用 -and。 -or 若操作符两边的任一个测试条件为真，则匹配。可以简写为 -o。 -not 若操作符后面的测试条件是真，则匹配。可以简写为一个感叹号（!）。 () 把测试条件和操作符组合起来形成更大的表达式。这用来控制逻辑计算的优先级。 默认情况下，find 命令按照从左到右的顺序计算。经常有必要重写默认的求值顺序，以得到期望的结果。 即使没有必要，有时候包括组合起来的字符，对提高命令的可读性是很有帮助的。注意 因为圆括号字符对于 shell 来说有特殊含义，所以在命令行中使用它们的时候，它们必须 用引号引起来，才能作为实参传递给 find 命令。通常反斜杠字符被用来转义圆括号字符。 上述表达式( expression 1 ) -or ( expression 2 )解释为：( file with bad perms ) -or ( directory with bad perms )，圆括号对于 shell 有特殊含义，我们必须转义它们，来阻止 shell 解释它们。 expr1 的结果 操作符 expr2 is... 真 -and 总要执行 假 -and 从不执行 真 -or 从不执行 假 -or 总要执行 预定义的操作 find 命令允许基于搜索结果来执行操作 操作 描述 -delete 删除当前匹配的文件。 -ls 对匹配的文件执行等同的 ls -dils 命令。并将结果发送到标准输出。 -print 把匹配文件的全路径名输送到标准输出。如果没有指定其它操作，这是 默认操作。 -quit 一旦找到一个匹配，退出。 -ok：交互式地执行一个用户定义的行为。 -exec command {} ; 这里的 command 就是指一个命令的名字，{}是当前路径名的符号表示，分号是必要的分隔符 表明命令的结束。 xargs xargs 命令从标准输入接受输入，并把输入转换为一个特定命令的 参数列表。find 命令提供的 -print0 行为， 则会产生由 null 字符分离的输出，并且 xargs 命令有一个 –null 选项，这个选项会接受由 null 字符 分离的输入。这里有一个例子： find ~ -iname ‘*.jpg’ -print0 xargs –null ls -l alien@localhost:~ $ mkdir -p playground/dir-{00{1..9},0{10..99},100} alien@localhost:~ $ touch playground/dir-{00{1..9},0{10..99},100}/file-{A..Z} alien@localhost:~ $ find playground -type f -name 'file-A' | wc -l 100 alien@localhost:~ $ touch playground/timestamp alien@localhost:~ $ stat playground/timestamp 文件：'playground/timestamp' 大小：0 块：0 IO 块：4096 普通空文件 设备：80ah/2058d Inode：1316820 硬链接：1 权限：(0664/-rw-rw-r--) Uid：( 1000/ alien) Gid：( 1000/ alien) 最近访问：2018-09-20 00:12:17.421846149 +0800 最近更改：2018-09-20 00:12:17.421846149 +0800 最近改动：2018-09-20 00:12:17.421846149 +0800 创建时间：- alien@localhost:~ $ touch playground/timestamp alien@localhost:~ $ stat playground/timestamp 文件：'playground/timestamp' 大小：0 块：0 IO 块：4096 普通空文件 设备：80ah/2058d Inode：1316820 硬链接：1 权限：(0664/-rw-rw-r--) Uid：( 1000/ alien) Gid：( 1000/ alien) 最近访问：2018-09-20 00:12:55.566202684 +0800 最近更改：2018-09-20 00:12:55.566202684 +0800 最近改动：2018-09-20 00:12:55.566202684 +0800 创建时间：- alien@localhost:~ $ find playground -type f -name 'file-B' -exec touch '{}' ';' alien@localhost:~ $ find playground -type f -newer playground/timestamp playground/dir-051/file-B playground/dir-007/file-B playground/dir-092/file-B playground/dir-068/file-B ... find 命令选项: 选项 描述 -depth 指示 find 程序先处理目录中的文件，再处理目录自身。当指定-delete 行为时，会自动 应用这个选项。 -maxdepth levels 当执行测试条件和行为的时候，设置 find 程序陷入目录树的最大级别数 -mindepth levels 在应用测试条件和行为之前，设置 find 程序陷入目录数的最小级别数。 -mount 指示 find 程序不要搜索挂载到其它文件系统上的目录。 -noleaf 指示 find 程序不要基于自己在搜索 Unix 的文件系统的假设，来优化它的搜索。 在搜索DOS/Windows 文件系统和CD/ROMS的时候，我们需要这个选项 Copyright © 2018 S all right reserved，powered by Gitbook该文件修订时间： 2018-09-21 09:31:06 "},"post/04-task-and-tools-2.html":{"url":"post/04-task-and-tools-2.html","title":"常见任务和基本工具(下篇)","summary":"Linux入门必备","keywords":"","body":"[TOC] 五、归档和备份 # 压缩程序 gzip – 压缩或者展开文件 bzip2 – 块排序文件压缩器 # 归档程序 tar – 磁带打包工具 zip – 打包和压缩文件 # 文件同步程序 rsync – 同步远端文件和目录 压缩文件 压缩算法：无损压缩保留了 原始文件的所有数据；有损压缩，执行压缩操作时会删除数据，允许更大的压缩。gzip/gunzip： alien@localhost:~ $ ls -l /etc > foo.txt alien@localhost:~ $ ls -l foo.* -rw-rw-r-- 1 alien alien 14700 9月 20 08:36 foo.txt alien@localhost:~ $ gzip foo.txt alien@localhost:~ $ ls -l foo.* -rw-rw-r-- 1 alien alien 2877 9月 20 08:36 foo.txt.gz alien@localhost:~ $ gunzip foo.txt.gz alien@localhost:~ $ ls -l foo.* -rw-rw-r-- 1 alien alien 14700 9月 20 08:36 foo.txt gzip 选项： 选项 说明 -c 把输出写入到标准输出，并且保留原始文件。也有可能用--stdout 和--to-stdout 选项来指定。 -d 解压缩。正如 gunzip 命令一样。也可以用--decompress 或者--uncompress 选项来指定. -f 强制压缩，即使原始文件的压缩文件已经存在了，也要执行。也可以用--force 选项来指定。 -h 显示用法信息。也可用--help 选项来指定。 -l 列出每个被压缩文件的压缩数据。也可用--list 选项。 -r 若命令的一个或多个参数是目录，则递归地压缩目录中的文件。也可用--recursive 选项来指定。 -t 测试压缩文件的完整性。也可用--test 选项来指定。 -v 显示压缩过程中的信息。也可用--verbose 选项来指定。 -number 设置压缩指数。number 是一个在1（最快，最小压缩）到9（最慢，最大压缩）之间的整数。 数值1和9也可以各自用--fast 和--best 选项来表示。默认值是整数6。 alien@localhost:~ $ ls -l /etc | gzip > foo.txt.gz # 没有必要指定.gz alien@localhost:~ $ gunzip foo.txt alien@localhost:~ $ ls -l foo.txt -rw-rw-r-- 1 alien alien 14700 9月 20 08:43 foo.txt # 查看压缩文件内容 alien@localhost:~ $ ls -l /etc | gzip > foo.txt.gz alien@localhost:~ $ gunzip -c foo.txt | less alien@localhost:~ $ ls bin foo.txt.gz 公共的 模板 视频 图片 文档 下载 音乐 桌面 # 与上面有同等作用 alien@localhost:~ $ zcat foo.txt.gz | less # 等同于上面的语句 alien@localhost:~ $ zless foo.txt.gz bzip2： 与 gzip 程序相似，但是使用了不同的压缩算法， 舍弃了压缩速度，而实现了更高的压缩级别。 如果你再次压缩已经压缩过的文件，实际上你 会得到一个更大的文件。这是因为所有的压缩技术都会涉及一些开销，文件中会被添加描述 此次压缩过程的信息。 归档文件 tar:扩展名为 .tar 或者 .tgz 的文件，它们各自表示“普通” 的 tar 包和被 gzip 程序压缩过的 tar 包 tar mode[options] pathname... tar 模式: 模式 说明 c 为文件和／或目录列表创建归档文件。 x 抽取归档文件。 r 追加具体的路径到归档文件的末尾。 t 列出归档文件的内容。 alien@localhost:~ $ mkdir -p playground/dir-{00{1..9},0{10..99},100} alien@localhost:~ $ touch playground/dir-{00{1..9},0{10..99},100}/file-{A..Z} # 模式和选项可以写在一起，而且不 需要开头的短横线。 alien@localhost:~ $ tar cf playground.tar playground alien@localhost:~ $ tar tvf playground.tar drwxrwxr-x alien/alien 0 2018-09-20 09:01 playground/ drwxrwxr-x alien/alien 0 2018-09-20 09:01 playground/dir-051/ -rw-rw-r-- alien/alien 0 2018-09-20 09:01 playground/dir-051/file-K ... # 抽取tar包到foo文件夹 alien@localhost:~ $ mkdir foo alien@localhost:~ $ cd foo # 类似于压缩 alien@localhost:~/foo $ tar xf ../playground.tar alien@localhost:~/foo $ ls playground 在现代 Linux 系统中， USB硬盘会被“自动地”挂载到 /media 目录下。我们也假定硬盘中有一个名为 BigDisk 的逻辑卷。 为了打包家目录文件，可以制作 tar 包 # 打包文件 sudo tar cf /media/BigDisk/home.tar /home # 抽取文件 cd / sudo tar xf /media/BigDisk/home.tar # 抽取单个文件 sudo tar xf archive.tar pathname tar 命令经常结合 find 命令一起来制作归档文件： alien@localhost:~ $ mkdir -p playground/dir-{00{1..9},0{10..99},100} alien@localhost:~ $ touch playground/dir-{00{1..9},0{10..99},100}/file-{A..Z} alien@localhost:~ $ find playground -name 'file-A' -exec tar rf playground.tar '{}' '+' alien@localhost:~ $ ls bin playground.tar 模板 图片 下载 桌面 playground 公共的 视频 文档 音乐 find 命令来匹配 playground 目录中所有名为 file-A 的文件，然后使用-exec 行为，来 唤醒带有追加模式（r）的 tar 命令，把匹配的文件添加到归档文件 playground.tar 里面。 alien@localhost:~ $ find playground -name 'file-A' | tar cf - --files-from=- | gzip > playground.tgz alien@localhost:~ $ ls bin playground playground.tar playground.tgz 公共的 模板 视频 图片 文档 下载 音乐 桌面 --file-from 选项（也可以用 -T 来指定） 导致 tar 命令从一个文件而不是命令行来读入它的路径名列表。现在的 GUN 版本的 tar 命令 ，gzip 和 bzip2 压缩两者都直接支持，各自使用 z 和 j 选项，上述命令简化为： find playground -name 'file-A' | tar czf playground.tgz -T - # 创建一个由 bzip2 压缩的归档文件 find playground -name 'file-A' | tar cjf playground.tbz -T - 把远端remote-sys主机下的`Documents`文件夹打包到本地系统 ssh remote-sys 'tar cf - Documents' | tar xf - zip： zip options zipfile file... alien@localhost:~ $ zip -r playground.zip playground adding: playground/ (stored 0%) adding: playground/dir-051/ (stored 0%) adding: playground/dir-051/file-K (stored 0%) ... alien@localhost:~ $ ls bin playground.tar playground.zip 模板 图片 下载 桌面 playground playground.tgz 公共的 视频 文档 音乐 使用-l 选项，导致 unzip 命令只是列出文件包中的内容而没有抽取文件。添加这个-v 选项会增加列表的冗余信息。 # 利用管道 alien@localhost:~ $ find playground -name \"file-A\" | zip -@ file-A.zip adding: playground/dir-051/file-A (stored 0%) adding: playground/dir-007/file-A (stored 0%) adding: playground/dir-092/file-A (stored 0%) unzip 程序，不接受标准输入。 # 与tar一样，zip 命令把末尾的横杠解释为 “使用标准输入作为输入文件。” alien@localhost:~ $ ls -l /etc/ | zip ls-etc.zip - adding: - (deflated 81%) 同步文件和目录 通过使用 rsync 远端更新协议，此协议 允许 rsync 快速地检测两个目录的差异，执行最小量的复制来达到目录间的同步。 rsync options source destination source 和 destination 两者之一必须是本地文件。rsync 不支持远端到远端的复制。source 和 destination 是下列选项之一： 一个本地文件或目录 一个远端文件或目录，以[user@]host:path 的形式存在 一个远端 rsync 服务器，由 rsync://[user@]host[:port]/path 指定 # -a 选项（递归和保护文件属性）和-v 选项（冗余输出） rsync -av playground foo 在网络间使用 rsync 命令 # 备份本地文件到远端 sudo rsync -av --delete --rsh=ssh /etc /home /usr/local remote-sys:/backup # 同步远端文件到本地 rsync -av -delete rsync://rsync.gtlib.gatech.edu/fedora-linux-core/development/i386/os fedora-devel 六、正则表达式 见笔记：https://blog.csdn.net/ds19991999/article/category/7887554 grep grep [options] regex [file...]，grep 程序会在文本文件中查找一个指定的正则表达式，并把匹配行输出到标准输出。 grep选项： 选项 描述 -i 忽略大小写。不会区分大小写字符。也可用--ignore-case 来指定。 -v 不匹配。通常，grep 程序会打印包含匹配项的文本行。这个选项导致 grep 程序只会打印不包含匹配项的文本行。也可用--invert-match 来指定。 -c 打印匹配的数量（或者是不匹配的数目，若指定了-v 选项），而不是文本行本身。 也可用--count 选项来指定。 -l 打印包含匹配项的文件名，而不是文本行本身，也可用--files-with-matches 选项来指定。 -L 相似于-l 选项，但是只是打印不包含匹配项的文件名。也可用--files-without-match 来指定。 -n 在每个匹配行之前打印出其位于文件中的相应行号。也可用--line-number 选项来指定。 -h 应用于多文件搜索，不输出文件名。也可用--no-filename 选项来指定。 alien@localhost:~ $ ls /bin > dirlist-bin.txt alien@localhost:~ $ ls /usr/bin > dirlist-usr-bin.txt alien@localhost:~ $ ls /sbin > dirlist-sbin.txt alien@localhost:~ $ ls /usr/sbin > dirlist-usr-sbin.txt alien@localhost:~ $ ls dirlist*.txt dirlist-bin.txt dirlist-sbin.txt dirlist-usr-bin.txt dirlist-usr-sbin.txt # 搜索所列文件中的 alien@localhost:~ $ grep bzip dirlist*.txt dirlist-bin.txt:bzip2 dirlist-bin.txt:bzip2recover alien@localhost:~ $ grep -l bzip dirlist*.txt dirlist-bin.txt # 查看不包含匹配项的文件列表 alien@localhost:~ $ grep -L bzip dirlist*.txt dirlist-sbin.txt dirlist-usr-bin.txt dirlist-usr-sbin.txt 元字符：^ $ . [ ] { } - ? * + ( ) | \\，可以把元字符用引号引起来阻止 shell 试图展开它们 插入符号和美元符号被看作是锚点，^匹配开头，$匹配尾部。 # 在我们的字典文件中查找到包含五个字母，且第三个字母 是“j”，最后一个字母是“r”的所有单词 alien@localhost:~ $ grep -i '^..j.r$' /usr/share/dict/words Major major POSIX 字符集 posix标准引入了”locale”概念，它能针对不同地区选择合适的字符集。： 字符集 说明 [:alnum:] 字母数字字符。在 ASCII 中，等价于：[A-Za-z0-9] [:word:] 与[:alnum:]相同, 但增加了下划线字符。 [:alpha:] 字母字符。在 ASCII 中，等价于：[A-Za-z] [:blank:] 包含空格和 tab 字符。 [:cntrl:] ASCII 的控制码。包含了0到31，和127的 ASCII 字符。 [:digit:] 数字0到9 [:graph:] 可视字符。在 ASCII 中，它包含33到126的字符。 [:lower:] 小写字母。 [:punct:] 标点符号字符。在 ASCII 中，等价于：[-!\"#$%&'()*+,./:;?@[\\]_`{\\ }~] [:print:] 可打印的字符。在[:graph:]中的所有字符，再加上空格字符。 [:space:] 空白字符，包括空格、tab、回车、换行、vertical tab 和 form feed.在 ASCII 中， 等价于：[ \\t\\r\\n\\v\\f] [:upper:] 大写字母。 [:xdigit:] 用来表示十六进制数字的字符。在 ASCII 中，等价于：[0-9A-Fa-f] 七、文本处理 cat – 连接文件并且打印到标准输出 sort – 给文本行排序 uniq – 报告或者省略重复行 cut – 从每行中删除文本区域 paste – 合并文件文本行 join – 基于某个共享字段来联合两个文件的文本行 comm – 逐行比较两个有序的文件 diff – 逐行比较文件 patch – 给原始文件打补丁 tr – 翻译或删除字符 sed – 用于筛选和转换文本的流编辑器 aspell – 交互式拼写检查器 文本应用程序 cat > foo.txt # 将输入cat重定向到foo.txt中，按CTRL+D结束 cat -ns foo.txt # 输出显示行号和禁止输出多个空白行 sort > foo.txt # 将输入sort重定向到foo.txt中，按CTRL+D结束 # 将三个文本文件合并为一个有序的文件 sort file1.txt file2.txt file3.txt > final_sorted_list.txt 常见的 sort 程序选项： 选项 长选项 描述 -b --ignore-leading-blanks 默认情况下，对整行进行排序，从每行的第一个字符开始。这个选项导致 sort 程序忽略 每行开头的空格，从第一个非空白字符开始排序。 -f --ignore-case 让排序不区分大小写。 -n --numeric-sort 基于字符串的数值来排序。使用此选项允许根据数字值执行排序，而不是字母值。 -r --reverse 按相反顺序排序。结果按照降序排列，而不是升序。 -k --key=field1[,field2] 对从 field1到 field2之间的字符排序，而不是整个文本行。看下面的讨论。 -m --merge 把每个参数看作是一个预先排好序的文件。把多个文件合并成一个排好序的文件，而没有执行额外的排序。 -o --output=file 把排好序的输出结果发送到文件，而不是标准输出。 -t --field-separator=char 定义域分隔字符。默认情况下，域由空格或制表符分隔。 # du 命令可以 确定最大的磁盘空间用户，输出结果按照路径名来排序 # head 命令，把输出结果限制为前 10 行 du -s /usr/share/* | head # 按数值排序 du -s /usr/share/* | sort -nr | head # 按照文件大小排序，5指第五个字段 ls -l /usr/bin | sort -nr -k 5 | head # 对第一个字段排序，指定了 1,1， 始于并且结束于第一个字段 # 第二个实例中，我们指定了 2n，意味着第二个字段是排序的键值 sort --key=1,1 --key=2n distros.txt # sort 程序使用一个排序键值，其始于第三个字段中的第七个字符 # n 和 r 选项来实现一个逆向的数值排序，b 选项用来删除日期字段中开头的空格 sort -k 3.7nbr -k 3.1nbr -k 3.4nbr distros.txt # -t 选项来定义分隔符 sort -t ':' -k 7 /etc/passwd | head uniq 会删除任意排好序的重复行（因为 uniq 只会删除相邻的重复行），并且把结果发送到标准输出。 它常常和 sort 程序一块使用，来清理重复的输出。 uniq 选项： 选项 说明 -c 输出所有的重复行，并且每行开头显示重复的次数。 -d 只输出重复行，而不是特有的文本行。 -f n 忽略每行开头的 n 个字段，字段之间由空格分隔，正如 sort 程序中的空格分隔符；然而， 不同于 sort 程序，uniq 没有选项来设置备用的字段分隔符。 -i 在比较文本行的时候忽略大小写。 -s n 跳过（忽略）每行开头的 n 个字符。 -u 只输出独有的文本行。这是默认的。 cut 程序选择项 选项 说明 -c char_list 从文本行中抽取由 char_list 定义的文本。这个列表可能由一个或多个逗号 分隔开的数值区间组成。 -f field_list 从文本行中抽取一个或多个由 field_list 定义的字段。这个列表可能 包括一个或多个字段，或由逗号分隔开的字段区间。 -d delim_char 当指定-f 选项之后，使用 delim_char 做为字段分隔符。默认情况下， 字段之间必须由单个 tab 字符分隔开。 --complement 抽取整个文本行，除了那些由-c 和／或-f 选项指定的文本。 # 抽取所有行第三个字段到标准输出 cut -f 3 distros.txt # 抽取所有行第三个字段后，再抽取每一个字段的7-10个字符 cut -f 3 distros.txt | cut -c 7-10 # 指定了分隔符 cut -d ':' -f 1 /etc/passwd | head paste 这个 paste 命令的功能正好与 cut 相反，会添加一个或多个文本列到文件中。 join 类似于 paste，它会往文件中添加列，通常与关系型数据库有关联。 # 不同的列项会添加到第二个file中 join distros-key-names.txt distros-key-vernums.txt | head 比较文本 comm 第一列包含第一个文件独有的文本行；第二列文本行是第二列独有的；第三列包含两个文件共有的文本行。comm 支持 -n 形式的选项，这里 n 代表 1，2 或 3。 # 隐藏输出结果的第1,2列 comm -12 file1.txt file2.txt diff 软件开发员经常使用 diff 程序来检查不同程序源码 版本之间的更改，diff 能够递归地检查源码目录，经常称之为源码树。 diff 更改命令： 改变 说明 r1ar2 把第二个文件中位置 r2 处的文件行添加到第一个文件中的 r1 处。 r1cr2 用第二个文件中位置 r2 处的文本行更改（替代）位置 r1 处的文本行。 r1dr2 删除第一个文件中位置 r1 处的文本行，这些文本行将会出现在第二个文件中位置 r2 处。 # 上下文模式，与github上面的一样 diff -c file1.txt file2.txt diff 上下文模式更改指示符： 指示符 意思 blank 上下文显示行。它并不表示两个文件之间的差异。 - 删除行。这一行将会出现在第一个文件中，而不是第二个文件内。 + 添加行。这一行将会出现在第二个文件内，而不是第一个文件中。 ! 更改行。将会显示某个文本行的两个版本，每个版本会出现在更改组的各自部分。 diff 统一模式更改指示符 字符 意思 空格 两个文件都包含这一行。 - 在第一个文件中删除这一行。 + 添加这一行到第一个文件中。 patch 它接受从 diff 程序的输出，并且通常被用来 把较老的文件版本转变为较新的文件版本。 diff -Naur old_file new_file > diff_file # 得到diff_file应用到旧文件中 patch tr 一种基于字符的查找和替换操作。 alien@localhost:~ $ echo \"lowercase letters\" | tr a-z A-Z LOWERCASE LETTERS 字符集可以用三种方式来表示： 一个枚举列表。例如， ABCDEFGHIJKLMNOPQRSTUVWXYZ 一个字符域。例如，A-Z 。注意这种方法有时候面临与其它命令相同的问题，归因于 语系的排序规则，因此应该谨慎使用。 POSIX 字符类。例如，[:upper:] # MS-DOS 文本文件为 Unix 风格文本,每行末尾的回车符需要被删除 tr -d '\\r' unix_file # 使用-s 选项，tr 命令能“挤压”（删除）重复的字符实例,重复的字符必须是相邻的 alien@localhost:~ $ echo \"aaabbbccc\" | tr -s ab abccc sed sed 的工作方式是要不给出单个编辑命令（在命令行中）要不就是包含多个命令的脚本文件名， 然后它就按行来执行这些命令。替换命令由字母 s后面跟着的字符来代表。 # 两条命令等价,将输入的文本中的front替换为back echo \"front\" | sed 's_front_back_' echo \"front\" | sed 's/front/back/' # 对仅有一行文本的输入流的第一行执行替换操作 echo \"front\" | sed '1s/front/back/' sed 地址表示法： 地址 说明 n 行号，n 是一个正整数。 $ 最后一行。 /regexp/ 所有匹配一个 POSIX 基本正则表达式的文本行。注意正则表达式通过 斜杠字符界定。选择性地，这个正则表达式可能由一个备用字符界定，通过\\cregexpc 来 指定表达式，这里 c 就是一个备用的字符。 addr1,addr2 从 addr1 到 addr2 范围内的文本行，包含地址 addr2 在内。地址可能是上述任意 单独的地址形式。 first~step 匹配由数字 first 代表的文本行，然后随后的每个在 step 间隔处的文本行。例如 1~2 是指每个位于偶数行号的文本行，5~5 则指第五行和之后每五行位置的文本行。 addr1,+n 匹配地址 addr1 和随后的 n 个文本行。 addr! 匹配所有的文本行，除了 addr 之外，addr 可能是上述任意的地址形式。 # 打印出一系列的文本行，开始于第一行，直到第五行 # 我们使用 p 命令， 其就是简单地把匹配的文本行打印出来 sed -n '1,5p' distros.txt sed 基本编辑命令: 命令 说明 = 输出当前的行号。 a 在当前行之后追加文本。 d 删除当前行。 i 在当前行之前插入文本。 p 打印当前行。默认情况下，sed 程序打印每一行，并且只是编辑文件中匹配 指定地址的文本行。通过指定-n 选项，这个默认的行为能够被忽略。 q 退出 sed，不再处理更多的文本行。如果不指定-n 选项，输出当前行。 Q 退出 sed，不再处理更多的文本行。 s/regexp/replacement/ 只要找到一个 regexp 匹配项，就替换为 replacement 的内容。 replacement 可能包括特殊字符 &，其等价于由 regexp 匹配的文本。另外， replacement 可能包含序列 \\1到 \\9，其是 regexp 中相对应的子表达式的内容。更多信息，查看 下面 back references 部分的讨论。在 replacement 末尾的斜杠之后，可以指定一个 可选的标志，来修改 s 命令的行为。 y/set1/set2 执行字符转写操作，通过把 set1 中的字符转变为相对应的 set2 中的字符。 注意不同于 tr 程序，sed 要求两个字符集合具有相同的长度。 # 可选标志是 g 标志，其 指示 sed 对某个文本行全范围地执行查找和替代操作 # 上边只是对第一个实例进行替换 echo \"aaabbbccc\" | sed 's/b/B/g' aspell 一款交互式的拼写检查器，拼写检查一个包含简单的文本文件，可以这样使用 aspell: aspell check textfile split（把文件分割成碎片）， csplit（基于上下文把文件分割成碎片），和 sdiff（并排合并文件差异） 八、格式化输出 nl – 添加行号 fold – 限制文件列宽 fmt – 一个简单的文本格式转换器 pr – 让文本为打印做好准备 printf – 格式化数据并打印出来 groff – 一个文件格式化系统 简单的格式化工具 nl - 添加行号： nl distros.txt | head 如果nl同时处理多个文件，它会把他们当成一个单一的 文本流，处理完一个标记元素之后，nl 把它从文本流中删除。它支持一个叫“逻辑页面”的概念。 nl标记： 标记 含义 \\:\\:\\: 逻辑页页眉开始处 \\:\\: 逻辑页主体开始处 \\: 逻辑页页脚开始处 nl 选项： 选项 含义 -b style 把 body 按被要求方式数行，可以是以下方式：a = 数所有行t = 数非空行。这是默认设置。n = 无pregexp = 只数那些匹配了正则表达式的行 -f style 将 footer 按被要求设置数。默认是无 -h style 将 header 按被要求设置数。默认是 -i number 将页面增加量设置为数字。默认是一。 -n format 设置数数的格式，格式可以是：ln = 左偏，没有前导零。rn = 右偏，没有前导零。rz = 右偏，有前导零。 -p 不要在没一个逻辑页面的开始重设页面数。 -s string 在没一个行的末尾加字符作分割符号。默认是单个的 tab。 -v number 将每一个逻辑页面的第一行设置成数字。默认是一。 -w width 将行数的宽度设置，默认是六。 fold - 限制文件行宽: # 设置行宽为12（字符），默认是80 echo \"The quick brown fox jumped over the lazy dog.\" | fold -w 12 # 增加s选项考虑单词边界 echo \"The quick brown fox jumped over the lazy dog.\" | fold -w 12 -s fmt - 一个简单的文本格式器：填充和连接文本行，同时保留空白符和缩进 # 设置50 个字符宽，fmt 会保留第一行的缩进 fmt -w 50 fmt-info.txt | head # 格式文件选中的部分，通过在开头使用一样的符号，注释行会合并 fmt -w 50 -p '# ' fmt-code.txt pr – 格式化打印文本 pr 程序用来把文本分页，当打印文本的时候，经常希望用几个空行在输出的页面的顶部或底部添加空白。此外，这些空行能够用来插入到每个页面的页眉或页脚。 -l 选项（页长）和 -w 选项（页宽）定义了宽65列，长15行的一个“页面”。 pr 为 distros.txt 中的内容编订页码，用空行分开各页面，生成了包含文件修改时间、文件名、页码的默认页眉 printf：主要用在脚本中，用于格式化表格数据 printf “format” arguments # 基本上和C语言一样 alien@localhost:~ $ printf \"I formatted the string: %s\\n\" foo I formatted the string: foo printf转换规范组件： 组件 描述 d 将数字格式化为带符号的十进制整数 f 格式化并输出浮点数 o 将整数格式化为八进制数 s 将字符串格式化 x 将整数格式化为十六进制数，必要时使用小写a-f X 与 x 相同，但变为大写 % 打印 % 符号 (比如，指定 “%%”) alien@localhost:~ $ printf \"%d, %f, %o, %s, %x, %X\\n\" 380 380 380 380 380 380 380, 380.000000, 574, 380, 17c, 17C 完整转换规范： %[flags][width][.precision]conversion_specification printf 转换可选规范组件 组件 描述 flags 有5种不同的标志:# – 使用“备用格式”输出。这取决于数据类型。对于o（八进制数）转换，输出以0为前缀.对于x和X（十六进制数）转换，输出分别以0x或0X为前缀。0–(零) 用零填充输出。这意味着该字段将填充前导零，比如“000380”。- – (破折号) 左对齐输出。默认情况下，printf右对齐输出。‘ ’ – (空格) 在正数前空一格。+ – (加号) 在正数前添加加号。默认情况下，printf 只在负数前添加符号。 width 指定最小字段宽度的数。 .precision 对于浮点数，指定小数点后的精度位数。对于字符串转换，指定要输出的字符数。 示例： 自变量 格式 结果 备注 380 \"%d\" 380 简单格式化整数。 380 \"%#x\" 0x17c 使用“替代格式”标志将整数格式化为十六进制数。 380 \"%05d\" 00380 用前导零（padding）格式化整数，且最小字段宽度为五个字符。 380 \"%05.5f\" 380.00000 使用前导零和五位小数位精度格式化数字为浮点数。由于指定的最小字段宽度（5）小于格式化后数字的实际宽度，因此前导零这一命令实际上没有起到作用。 380 \"%010.5f\" 0380.00000 将最小字段宽度增加到10，前导零现在变得可见。 380 \"%+d\" +380 使用+标志标记正数。 380 \"%-d\" 380 使用-标志左对齐 abcdefghijk \"%5s\" abcedfghijk 用最小字段宽度格式化字符串。 abcdefghijk \"%d\" abcde 对字符串应用精度，它被从中截断。 文件格式化系统 groff：一套用GNU实现 troff 的程序。它还包括一个脚本，用来模仿 nroff 和其他 roff 家族。linux手册页由 groff 渲染，使用 mandoc 宏包。 # 默认以 PostScript格式输出，这里制定了ascii格式 zcat /usr/share/man/man1/ls.1.gz | groff -mandoc -ascii | head # PostScript 输出的文件转换为PDF文件： ps2pdf ~/Desktop/foo.ps ~/Desktop/ls.pdf 将 -t 选项添加到 groff 指示它用 tbl 预处理文本流。同样地，-T 选项用于输出到 ASCII ，而不是默认的输出介质 PostScript。 Copyright © 2018 S all right reserved，powered by Gitbook该文件修订时间： 2018-09-21 09:31:23 "},"post/05-compile-program.html":{"url":"post/05-compile-program.html","title":"编译程序","summary":"Shell必备基础","keywords":"","body":"编译程序 make - 维护程序的工具 构建程序 大多数程序通过一个简单的，两个命令的序列构建： ./configure make 这个 configure 程序是一个 shell 脚本，由源码树提供.它的工作是分析程序构建环境。大多数源码会设计为可移植的。configure 命令会创建了几个新文件。最重要一个是 Makefile。Makefile 是一个配置文件， 指示 make 程序究竟如何构建程序。make 程序把一个 makefile 文件作为输入（通常命名为 Makefile），makefile 文件 描述了包括最终完成的程序的各组件之间的关系和依赖性。 安装程序 sudo make install Linux命令总结 linux命令总结.pdf Copyright © 2018 S all right reserved，powered by Gitbook该文件修订时间： 2018-09-21 15:56:22 "},"GLOSSARY.html":{"url":"GLOSSARY.html","keywords":"","body":"Copyright © 2018 S all right reserved，powered by Gitbook该文件修订时间： 2018-08-25 19:31:00 "}}